    //============================================ Prometheus Front-End ===========================================================




    //==============================================  ПЕРВАЯ НЕДЕЛЯ ===============================================================

/* Роадмап фронтендера - https://roadmap.sh/roadmaps/frontend.png . Этот курс будет охватывать основы для фронтенд разработчика на 
    карте это все блоки до центрального блока - web security knowledge. Все остальное не факт что пригодится, так что нужно учить
    только то что нужно для работы в текущий момент или перспективное(для продвижения карьеры/работы над новый проектом),
    а не хвататься за все подряд, а то получится что можно знать много поверхностно. Также нужно очень много практиковаться что бы 
    теория не забывалась и получать новый опыт при разработке и дебаггинге(поиске ошибок) кода. */
         
    
{//    ====    ЭФФЕКТИВНЫЙ ПРОЦЕСС РАЗРАБОТКИ     ====

    /* Для того чтобы писать код эффективно нужно настроить и автоматизировать этот процесс. Он состоит из нескольких частей:
         1) настройка среды разработки,
         2) как искать информацию,
         3) работа с ошибками. */
    

  /*1) Настройка среды разработки:
        - выберете комфортный редактор кода, настройте его так что бы было удобно работать

        Словник
        Редактор коду — текстовий редактор для створення та редагування коду програм. Він може бути окремим додатком або вбудованим 
            в інтегроване середовище розробки (IDE).

        IDE (інтегроване середовище розробки) — редактор коду, який має більше можливостей, може працювати з допоміжними системами,
            такими як багтрекер, контроль версій і т.д.

        Плагін — модуль, який підключається до програми і дає їй додаткові можливості.

        Рефакторинг — контрольований процес покращення вашого коду, без написання нової функціональності.

        Дефолтний (англ. default) — сленгова назва, що означає “за замовчуванням”.


    2) Поиск информации:
        - MDN https://developer.mozilla.org
        - Stack Overflow https://stackoverflow.com/ - форум для программистов, можно задать вопрос если не нагуглили.
        - научитесь гуглить(правильно вводить запрос) - например если нужно найти метод который превращает строку в число, а мы не
            помним как он называется нужно загуглить - сначала пишем на каком языке(чтобы сузить область поиска) Javascript, потом
            максимально коротко пишем что мы хотим найти convert string to number. Лучше гуглить сразу на английском языке, так 
            больше шансов что информация найдется.
        - задавайте вопросы и помогайте другим.
        - практикуйтесь, выполняйте задание разными способами.


    3)(1.1.7) Работа с ошибками:
        - Если код не работает, нужно его дебажить(найти ошибку). Ошибки бывают синтаксические и логические. Про синтаксические
            зачастую браузер сделает сообщение в консоли. Если она там есть но не понятно что за ошибка, можно ее скопировать и
            загуглить.
        - Если ошибка логическая, то нужно понимать что происходит в коде, какие данные должны быть на входе или выходе из
            ф-и, какие значения должны быть присвоены переменным. Это можно сделать двумя способами: 
            а) добавить в код console.log() в нужном месте или ключевое слово debugger - он остановит выполнение ф-и в нужном 
            месте и в инспекторе можно будет просмотреть данные в данный момент, или добавить alert() - но его не рекомендуют 
            использовать, потому что если его забыть удалить то это сразу выразится в работе сайта и будет всем видно в отличие
            от консольлога.

            b)использовать инструменты дебаггинга самого браузера. Рассмотрим на примере GoogleChrome,
            Открыть инструменты разработчика можно нажав f12 или Crtl + Shift + I или нажав в правом верхнем углу 
                три точки(меню)-> другие инструменты-> инструменты разработчика.
            Откроется поле с 8ю закладками. Чаще всего используют:
       
            - Sources - вкладака используется для дэбаггинга. Тут можно видеть какие документы подключены, ставить брейкпоинты, на 
                которых браузер будет останавливать выполнение кода и анализировать данные которые приходят.
                Например выбрав JS файл видим свой код.
                
                function showText(el) {
                    if(el.previousElementSibling.clientHeight === 80){
                        el.previousElementSibling.style.height = "100%";
                        el.innerHTML= "Show less";
                    } else {
                        el.previousElementSibling.style.height = "80px";
                        el.innerHTML= "Read more...";
                    }
                И кликнув слева от него на номере строки например 2, 4, 6, потом на странице нажимаем на кнопку Read more... и
                программа останавливается сначала на 2й строке(if), наведя курсор на el в showText(el) можно увидеть информацию
                про передаваемый объект. А если нужно увидеть какие данные пришли выделяем фрагмент строки
                el.previousElementSibling.clientHeight и правой кнопкой кликаем на нем выбрав add to watch и в окне справа
                раскрывается секция watch в которой видно какой элемент и какое значение пришло. 
                *Что бы продолжать работу программы далее нужно нажать кнопку справа над панелькой "Resume script execution F8",
                тогда выполнение кода продолжится до следующего брейкпоинта строка 4(innerHTML), нажимаем еще раз и программа
                проскакивает(не останавливается на строке 6(превая строка блока else)) потому что туда код не дошел, так как
                выполнилось первое условие блока if else.

                В меню Call Stack - видим какие ф-ии сейчас выполняются, если нажать на ф-ю anonymous -  будет состояние до того
                как showText была вызвана. Если нажать на ф-ю то справа в окне Scope можно увидеть к каким переменным имеет доступ
                ф-я на текущем рядке кода  


        Корисні посилання
            
        HTML
        https://html.com/
        
        CSS
        https://css-tricks.com/
        
        JS Visualizer
        https://www.jsv9000.app/
        
        Algorithm Visualizer
        https://algorithm-visualizer.org/
        
        Git and GitHub
        https://learngitbranching.js.org/?locale=uk
        
        React Tutorial
        https://react-tutorial.app/
        
        API
        https://rapidapi.com/learn
        
        Web3
        https://www.useweb3.xyz/  */

}


{/*    ====    КАК РАБОТАЕТ WEB     ====

    +++ Как работает ИНТЕРНЕТ

        IP адреса — (Internet Protocol address) - ідентифікатор (унікальний числовий номер) мережевого рівня, який використовується 
            для адресації комп'ютерів чи пристроїв у мережах.
            
        Сервер — комп'ютер, який обслуговує всі підключені до нього персональні комп'ютери. При цьому сервер виконує свої функції і 
            завдання без участі в цьому процесі людини, тобто самостійно.

        Клієнт — апаратний або програмний компонент обчислювальної системи, що надсилає запити серверу.

        Інтернет-провайдер — компанія, яка надає доступ до інтернету.

        Роутер (маршрутизатор) — спеціалізований пристрій, який пересилає пакети між різними сегментами мережі на основі правил та 
            таблиць маршрутизації.
            
        Пакет — одиниця даних, складена в єдиний пакет, який рухається по заданому мережевому шляху.


        Интернет - может передаваться по кабелю, через спутник или моб. связь. Он дает возможность общаться между собой компьютерам 
            или устройствам которы подключены к этому кабелю/спутник/моб. связь. Сервер это копмьютер подключенный к интернет,
            на его жестких дисках хранятся страницы. У каждого сервера есть уникальный IP адресс (интернет протокол) это как у нас
            физический адресс.
            Благодаря IP адрессу компьютеры могут находить друг друга. Но поскольюку числовое представление IP адресса мы не запомним
            (57.148.46.375) мы даем серверам названия(google.com).

            У домашнего компьютера есть IP адресс, но он не является сервером, так как подключен к интернету не напрямую. Такие 
            компьютеры  называются клиентами, потому что для доступа в интернет они используют провайдера. Тоесть когда на
            дом. компе хотим зайти на свою почту на gmail.com сначала провайдер дает доступ к интернету дом.компу, потом с сервера 
            gmail загружаются страницы и потом мы можем их просмотреть на дом. компе.
             
            Когда информация(картинки, страницы, ...) путешествует по интернету то компьютеры их разбивают на небольшие части - 
            пакеты. Когда они доходят к пункту назначения(полностью загружаются) они заново собираются в заданой последовательности.
                                    
            Если два комьютера подключены к одному кабелю с интернетом, то что бы каждому приходила своя информация, они должны быть 
            подключены к роутеру(маршрутизатору) который присвоит каждому компу свой IP адресс. На пути следования запроса от дом. 
            компа к серверу может быть много роутеров и каждый перед отправкой запроса дальше добавляет к нему свой IP как обвертку.
            Таких обверток может быть около 20 ти пока запрос дойдет до сервера, потом сервер формирует ответ и добавляет  эти IP 
            адресса обертки в том же количестве и порядке как они к нему пришли. А когда информация будет идти назад к комьютеру,
            каждый роутер будет забирать свою обертку IP при отправке информации дальше к пользователю.
            
            
        Разница интернета и веба(www)
            Интернет это - сеть, возможность компьютеров соединятся друг с другом. В этом процессе web(всемирная паутина) - может и
                не принимать участия.

            Всемирная паутина(web) - это страницы которым мы видим используя приборы которые находяться в сети, то есть это коллекция 
                информации к которой мы имеем доступ благодаря интернету.
                
            Интернет это как дороги которые соединяют города, а web(всемирная паутина) - это здания или магазины которые находятся 
                возле дороги. Чтобы зайти в магазин - нужно пройти по дороге. Чтобы получить доступ к web нужно воспользоваться
                интернетом.

        Як працює WWW та браузер (базовий курс)
        https://courses.prometheus.org.ua/courses/course-v1:LITS+114+2022_T2/courseware/b52fdaef66554d7cbb90805509f00c03/765e604d9d1746ff84301b1d165ce2ae/?child=first 

        How Does the Internet Work?
        https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm




    +++ Как работает WEB(WWW - world wide web)

        Словник
        Інспектувати код — перевіряти код програми, не лише для виявлення помилок, а й для покращення загальної якості програмного 
            коду.

        IPv4 — четверта версія інтернет-протоколу (IP), яка використовує 32-бітові (чотирьохбайтні) адреси, що обмежують адресний 
            простір. Формою запису IPv4-адреси є запис як чотирьох десяткових чисел (від 0 до 255), розділених точками. Через дріб
            вказується довжина маски підмережі.
            Наприклад: 172.16.254.1

        IPv6 — 
        нова версія інтернет-протоколу (IP), покликана вирішити проблеми, з якими зіткнулася попередня версія (IPv4). Довжина адреси
        IPv6 становить 128 біт. В IPv6-адресі записами є вісім 16-бітних блоків, розділених двокрапками.
        Наприклад: 2001:0db8:0000:0000:0000:8a2e:0370:7334

        Кеш (англ. cache) — особлива швидкісна пам'ять або частина оперативної пам'яті, де зберігаються копії часто використовуваних 
            даних. 

        Закешовані дані (англ. cached data) — колекція даних, що дублюють початкові значення, збережені в іншому місці на вашому 
            пристрої, зазвичай для полегшення доступу.
            
        Система доменних імен - DNS (англ. Domain Name System) — комп'ютерна розподілена система для отримання інформації про домени.
            Найчастіше використовується для отримання IP-адреси за ім'ям хоста.
            
        Запит (англ. request) — запит до сервера, який його обробляє.

        Відповідь (англ. response) — відповідь, яку повертає сервер.

        Headers — спеціальні параметри, які несуть певну службову інформацію про з'єднання HTTP.

        Фреймворк (англ. framework) — це своєрідний каркас для створення комп’ютерних програм. Фреймворк «нав’язує» розробнику певні 
            архітектурні обмеження при створенні програм.
            
        JSON (англ. JavaScript Object Notation) — текстовий формат обміну даними, що базується на JavaScript. Але при цьому формат 
            незалежний від JS може використовуватися в будь-якій мові програмування.
            
        Web Sockets — це передова технологія, яка дозволяє створювати інтерактивне з'єднання між клієнтом (браузером) та сервером для
            обміну повідомленнями у режимі реального часу.
            

        Вспомним ранее изученное в предыдущем курсе и немного углубимся в детали. Время от времени будем возвращаться к некоторым 
            частям этого видео чтобы рассмотреть их детальнее, потому что весь курс в целом построен вокруг того как работает веб,
            как браузер интерпретирует написанный код, как реагирует на события пользователя и в какой последовательности их исполняет,
            как делает запрос на сервер, получает и обрабатывает информацию от него.
            
            Начнем с самого распространенного сценария. 
            Открываем браузер вводим адресс сайта и нажимаем ентер. Сайт сохранен где-то на сервере. Нашу веб страницу сервер мог 
            сгенерировать или уже сохраненную отослать в ответ на запрос. А браузер если сильно упростить - интерпретатор,
            который получил страницу, прочитал код, пропроцессил его и отобразил на экране. Это в общех чертах, детальнее поговорим в
            следующем видео, сейчас же нам нужно понимать что страница на экране была сгенерирована на сервере и прислана в браузер
            по его запросу. Важный вопрос на этом этапе - откуда сервер знает что мы обращаемся именно к нему когда вводим адресс 
            сайта  - потому что серверов очень много. Официальный адресс сайта - это IP адресс.
            IP - internet protocol, он выглядит так IPv4 172.16.254.1 или в современном виде немного сложнее 2001:0db8:0000:0000:0000:8a2e:0370:7334
            - IPv6. Конечно такие числа нам трудно запомнить и каждый раз вводить их неудобно(хотя и можем).

            Первое что делает браузер когда мы ввели доменное имя и нажали энтер - превращает доменное имя в IP адресс. Сначала 
            браузер смотрит в свои захешированные данные, если мы уже посещали этот сайт то IP адресс хранится в них.
            Если не посещали, тогда браузер обращается к DNS(Domen name system - система доменных имен) серверу - это большой 
            справочник где каждому доменному имени присвоен свой IP адресс.
            ДНС сервер превращает дом. имя в IP адресс и отсылает назад браузеру и уже по IP адресс браузер обращается к веб серверу.
            Веб сервер в ответ на запрос браузера посылает ему готовую или вновь сгенерированную страницу.
            Браузер получив такую страницу знает что делать дальше и как ее обработать.

            Часть где мы вводим url адресс в адрессную строку называется - request(запрос). Браузер делает запрос к веб серверу за конкретной
            информацией. request(запрос) - это набор данных где url адресс только часть данных. Можно открыть панель управления разработчика
            -> вкладку Network(нажать на строку во вкладке name) и просмотреть детали запроса. Сюдаже входит и тип запроса request method. 
            Для получения информации(GET)и сохранения информации на сервере(POST) используют разные типа запросов, их мы рассмотрим дальше в курсе.
            Запрос может содержать meta(мета) данные - которые мы называем хедерами(response headers) - это дополнительная информация как для
            сервера так и для браузера. Всё что браузер получает в ответ на свой запрос называется - response(вкладка тут же). Традиционно на
            первый запрос браузер получает index.html - страницу, которая содержит хтмл код который браузер процессит и отображает на экране.



        *** Примененные технологии.
            Разобрались с процессом, теперь посмотрим какие технологии применяются на каждом этапе. 
            
            Всё что мы видим на экране - результат взаимодействия 3х технологий: HTML(язык разметки - отвечает за структуру сайта,  за то где и какие
            эл. должны размещаться, браузер понимает хтмл потому что это стандартизированный язык), CSS(создает хороший внешний вид сайта),
            JavaScript(логика и динамика сайта -  если сайт должен реагировать на действия пользователя, отправлять данные формы или выполнять любое 
            другое взаимодействие с пользователем). 

            Вся эта передача данных тоже стандартизирована, например какой вид должен быть у request(запрос) и response(ответ). Вид определяется
            технологией которая при этом применяется, например HTTP - hypertext transport protocol, также есть еще стандарт HTTPS - hypertext transport 
            protocol secure - это тоже самое но в зашифрованой форме. Все современныйе сайта используют HTTPS, поэтому данные отправляемые на сервер и
            получаемые с него зашифрованы, а значит защищены, только браузер и сервер обмениваются между собой специальными ключами благодаря которым
            могут расшифровать данные отдельно на стороне браузера или на строне сервера. Но пока данные в процессе передачи - они зашифрованы, и если
            кто-то перехватит нашу транзакцию(а такое технически возможно) он получит только набор непонятных символов, а не посылаемые данные.

            Для того чтобы страницу можно было генерировать на сервере используются серверные языки программирования: php, node.js, python, java или
            фреймворки на основе этих языков программирования(джанго...). Простыми словами фреймворки - это наборы вспомогательных инструментов которые
            упрощают процесс разработки, то есть не нужно каждый раз изобретать колесо и сосредотачиваться на деталях разработки, фреймворки это берут
            на себя, мы же можем сосредоточится на общей бизнес логике. Такие же фреймворки существуют и для фронтенда - react, angular, vue(коротенько
            ознакомимся с ними в конце курса).

            Так в целом работает веб. Но он намного больше чем просто хтмл код. Например мобильные приложения как например твиттер или фейсбук и данные
            которые в них приходят извне из сети, например картинки или посты которые выкладывают ваши друзья, но в этом случаем мы не получаем хтмл
            страницу в response, а только набор данных которые нужно отобразить на экране нашего приспособления(телефон/планшет). Поэтому нужно понимать
            что под словом веб подразумевается не только веб страницы, а любое взаимодействие пользовательского приспособления находящегося в сети с 
            сервером который находится далеко(не в комнате). Request/response паттерн всегда тот самый(одинаковый) разница только в формате данных которые
            пересылаются. В случае с браузером на первый запрос он получает документ в формате хтмл, но если это мобильное приложение оно получает данные
            в формате json(java script object notation) - его мы рассотрим позже на курсе. Формат данных указывается в header запроса. Если браузер получает 
            ответ формате json, то он понимает что их не нужно анализировать, парсить, отображать, а только передать в приложение и уже код написанный 
            разработчиками разберется что с этими данными дальше делать.

            Тоесть форматы данных могут быть разными, постоянная только идея обмена информацией между фронтендом и сервером и дальнейшим процессингом этой
            информации браузером или кодом приложения. Есть более прогрессивные технологии, когда браузеру не обязательно делать запрос данных, сервер
            может присылать их самостоятельно когда такие данные у него появляются браузеру при этом нужно установить постоянную связь с сервером и не 
            закрывать её(связь) и когда на сервере появятся определенные данные он их отправить автоматически - такая технология называется веб сокеты и на
            ее основе построены большинство онлайн игр и чатов.

            How DNS works (comics)
            https://howdns.works/ep1/
  
*/}


{/*    ====    РЕНДЕРИНГ     ====

    +++ Процесс отображения web страницы (1.3.1)

        Код браузера написан на С++. 

        С++ — мова програмування, яка представляє високорівневу мову програмування загального призначення зі статичною типізацією, що 
            підходить для створення найрізноманітніших додатків.

        Механізм рендерингу (англ. Rendering engine) — програмне забезпечення в рамках браузера, яке визначає, що показати користувачу 
            на основі отриманих файлів. Головний програмний компонент кожного браузера.

        Синтаксичний аналіз (англ. parsing) — це процес аналізу вхідної послідовності символів, з метою розбору граматичної структури 
            згідно із заданою формальною граматикою.

        Синтаксичний аналізатор (англ. parser) — це програма або частина програми, яка виконує синтаксичний аналіз.

        Алгоритм — скінченна чітка послідовність дій, спрямованих на досягнення поставленої мети або розв'язування задач певного типу.

        Рендеринг (англ. rendering) — це процес отримання зображення за допомогою комп'ютерної програми.

        Об'єктна Модель Документа (англ. Document Object Model - DOM) — структура документа, представлена у вигляді дерева.

        Об'єктна модель CSS (англ. CSS Object Model - CSSOM) — набір API-інтерфейсів, що дозволяють маніпулювати CSS з JavaScript. Це дуже 
            схоже на DOM, але для CSS, а не HTML.

        Чанк (англ. chunk) — маленький фрагмент інформації.

        Токен (англ. token) — сутності, які браузер утворює з символів

        Вузол (англ. Node) — точка, поєднана залежностями з декількома або всіма іншими. «Вузол» у цьому контексті — це просто елемент HTML. 
            "DOM" - це деревовидна структура, яка представляє HTML веб-сайту, а кожен елемент HTML є "вузлом"

        Рекурсія — процедура, у тілі якої знаходиться явне звернення до неї самої.


        Понимая логику работы браузера, то как он работает с тегами и как применяет к ним стили, что ускоряет его работу, что притормаживает,
            и вообще как он прорисовывает страницу наш мозг будет сразу заточен под написание оптимального хтмл, ксс, JS кода который без
            дополнительных задержек отработает для пользователя.

        Веб браузер - это часть програмного обеспечения которая загружает файлы из отдаленного сервера или локального диска, а в рамках браузера
            есть програмное обеспечение которое определяет что должно быть показано пользователю на основе полученных файлов - rendering engine(
            механизм рендеринга). rendering engine - главный програмный компонент каждого браузера, и разные производители браузеров могут 
            называть его по разному, потому что может быть разница в алгоритмах и способах обработки кода. Хоть есть такая разница, но этапы
            построения веб страницы мало отличаются, поэтому допустим что у нас есть один универсальным механизмом браузера. rendering engine(
            механизм рендеринга) - хоть и главная но все-таки часть браузера.

        Отправка и получение информации. Вспомним что данные пересылаемые по сети имеют вид пакетов(разделены на части/пакеты). Эти пакеты браузер
            получает небольшими частями чанками(chunk), браузер не ждет получения полной страницы, а начинает работать с тем что уже пришло. Когда
            мы написали хтмл, ксс, JS код и потом открываем хтмл файл - браузер видит необработанные байты данных, а не фактические символы которые
            мы написали. С этого момента ему нужно превратить эти необработанные байты в тот формат, который он поймет. Поскольку первым браузер
            получает index.html то с него и начинается процесс обработки Parsing(синтаксический анализ). 
            

            Браузеру нужно работать с ДОМ объектом
            (Document object model), но как его получить. Во первых необработанные байты перекодируются в символы, а они превращаются в сущности
            которые называются токенами. Обычный набор символов никак не поможет браузеру, и без процесса токенизации браузер может только отобразить
            набор символов которым мы прописали в хтмл, ксс, JS файле и это никак не будет похоже на веб страницу. Когда мы сохраняем документ
            с расширением .html => HTML мы даем сигнал браузеру что этот документ нужно интерпретировать именно как хтмл документ. Способ которым
            браузер интерпретирует этот файл заключается в синтаксическом анализе когда браузер должен распознать каждый открывающий и закрывающий 
            тег <html></html>. Синтаксический анализатор(parser) сначала находит открывающие и закр. скобки < > и понимает что между ними найдет
            название тега, и также знает набор правил которые применяются к каждому тегу. Можно представить токен как структуру данных в которой
            есть информация про определенный хтмл тег.

            После процесса токенизации браузеру нужно превратить их в ноды(объекты с определенными свойствами или сущность ДОМ) из этих нод браузер
            составляет ДОМ и создает родительско-дочерние-соседские связи между нодами, так на выходе мы получаем полноценный ДОМ с которым можно
            работать.

            Bytes(байты) => Characters(символы) => Tokens => Node(узел) => DOM
            
            Чем больше ХТМЛ файл тем дольше будет происходить парсинг, поэтому нужно не использовать лишние теги и не оборачивать информацию в теги
            без которых можно обойтись.


            Для анализа хтмл, ксс, js кода в рендер енжин используются разные парсеры. Хтмл парсер благосклонно относится к вашему коду и при
            некоторых ошибках старается отобразить хтмл страницу максимально хорошо. Разработчик может пропустить некторые закрывающие теги, если это
            не критические закр. теги то браузер может их добавить сам. Можно написать больше однотипных вложенных тегов чем позволяет норма браузера
            (она разная для разных браузеров) - браузер постарается проигнорировать лишние теги и отобразить страницу без ошибок. Также разработчик
            может добавить тег которого нету в словаре браузера, браузер запомнит его и попробует разобраться с ним позже. И так далее...
            Ксс и JS парсеры таких ошибок не прощают.

            
            Если в ХТМЛ файл добавленна ссылка на ксс файл в хед. По мере того как браузер получает данные хтмл документа и запускает процесс построения
            ДОМ дерева он находит тег link <link rel="stylesheet" href="./css/main.css"> и сразу делает запрос по ксс файлу и тоже получает в ответ
            необработанные байты, и происходит процесс похожий на тот который мы видели только вместо ДОМ складывается структура древовидная структура
            КСС обджект модел. Ксс стили применяются к элементу определенный каскадом(то как браузер понимает какие стили применить к конкретному эл.).
            Стили могут быть унаследованы от родительского элемента или непосредственно назначеными элементу - древовидная структура становится важной,
            это связанно с тем что браузер рекурсивно проходить структуру дерева ксс и определять стили которые надо применить к конкретному эл. На
            этом этапе у браузера есть две древовидные независимые структуры DOM(взаимосвязи между эл.) и CSSOM(вид элем.) теперь браузеру нужно соединить
            их в одно целое в Render Tree(дерево визуализации) - содержит информацию про всё видимое содержимое Object model на странице с конкретными
            примененными к нему ксс стилями. Если какой-то эл. был спрятан с помощью ксс например через display:none - то он не будет добавлен в
            Render Tree, так же сюда не попадет то что находится в теге head, тоесть можно сделать вывод что Render Tree - это все что пользователь видит
            на экране. Спрятанные эл. будут присутствовать в DOM но не будут в Render Tree.

            Bytes(байты) => Characters(символы) => Tokens => Node(узел) => CSSOM


            С построенным Render Tree(деревом визуализации) браузер переходит к следующему этапу - Layout. Это расчет размера и положения каждого эл. на
            странице. Это всё равно что передать всю информацию про содержимое страницы и примененные стили математику который рассчитает размер эл-тов
            и где они должны располагаться отталкиваясь от области браузера доступной для просмотра.

            HTML -> DOM  --_
                            \
            Parsing => Render Tree => Layout
                            /
            CSS -> CSSOM --`


            Когда браузер имеет полную информацию про размер и размещение эл. на странице наступает этап прорисовки и наконец пользовать может увидеть
            страницу такой, какой она была задумана.

            HTML -> DOM  --_
                            \
            Parsing => Render Tree => Layout => Paint
                            /
            CSS -> CSSOM --`
        

        Теперь представим что изменился размер окна браузера или пользователь открыл выпадающее меню, браузер должен держа в памяти ДОМ дерево, CSSOM и
            Render Tree проверить нужно ли что то добавить или удалить из рендер дерева, пересчитает размер и положение эл. еще раз и снова прорисует
            новое Render Tree. Этот процесс называется re-layout.

            Parsing => Render Tree => Layout => Paint
                                        |
                                    re-layout => re-paint


            Если же структура Render Tree не требует изменений, например изменился только цвет кнопки, тогда браузер применит необходимые стили и 
            выполнит только последний этап re-paint

            Parsing => Render Tree => Layout => Paint
                                                  |
                                               re-paint


        How Browsers Work: Behind the scenes of modern web browsers
        https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ 




    +++ Что блокирует рендеринг (1.3.2)

        Скрипт — набір команд на тій чи іншій мові програмування.

        Ресурсы которые блокируют рендеринг - к ним относится, всё что может помешать браузеру прорисовать страницу или прорисовать ее быстро.
            Что это может быть, например каждый пристойный веб сайт содержит JS код - благодаря которому можно изменять содержимое и стили страницы,
            удалять или добавлять узлы ДОМ дерева, изменять CSSOM это чудесно, но имеет свою цену.

            Рассмотрим пример в папке rendering-blocking(хтмл, ксс, Js файлы). В индекс.хтмл такой код

                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Rendering</title>
                        <link rel="stylesheet" href="main.css" />
                        <script defer type="text/javascript" src="app.js"></script>
                    </head>
                    <body>
                        <h1 id="header">How Browser Rendering Works</h1>
                        <img src="rendering.png" alt="rendering" />
                    </body>
                </html>
            
            Тут у нас есть заголовок и изображение. Также есть немного ксс стилей. body {
                background: #13B5EA;
                }

                h1 {
                text-align: center;
                }

                img {
                width: 100%;
                }

            Рассмотрим что произошло. Браузер получил байты данных ХТМЛ файла трансформировал их в символы, а потом в токены, по мере того как парсер
            попал на тег линк <link rel="stylesheet" href="main.css" /> браузер загрузил ксс файл, завершил конструирование ДОМ дерева и приступил к
            CSSOM, потом их соединил и создал render tree(дерево визуализации) и в результате его отобразил. Но Как изменятся эти шаги если мы добавим
            JS скрипт <script type="text/javascript" src="app.js"></script>. Код в JS файле будет искать id="header" и выводить его в консоль.
            
            Запомним что как только браузер наталкивается на тег script он ставит на паузу все что делал до этого и ждет пока загрузится и отработает
            скрипт, это потому что JS может изменять как ДОМ так и КССОМ. Поскольку браузер не знает что делает именно этот скрипт он употребляет меры
            безопасности полностью останавливая конструирование ДОМ вообще. 
            
            Почему это может быть плохо? Поместим скрипт перез закрывающим тегом </body>, откроем консоль и обновим страницу. Что сделал скрипт - он
            отработал, нашел тег с id="header" и вывел его в консоль. Но если поднять тег script в тег <head> и разместить после ссылки на ксс файл,
            обновить страницу, то в консоль выведется null, то есть скрипт не отработает как нужно, потому что пока выполняется скрипт, браузер остановил
            рендеринг и не создал узлы, а скрипт пытается найти узел который еще не был создан и не может. Поэтому запомним - место размещения JS скрипта
            имеет значение.

            Сейчас JS файл находится в той же папке что и хтмл файл и мы его загружаем локально(из файловой системы), но мы можем также добавить файл с JS
            кодом который нужно будет загрузить через интернет. Если интернет слабый, то браузер будет еще ждать пока загрузится файл, потом ждать когда
            скрипт выполнится и только потом продолжит рендеринг, это могут быть большие потери продуктивности. По умолчанию каждый скрипт - это блокер
            для парсера, но можно изменить поведение по умолчанию. Это делается при помощи ключевых слов async/defer.

            async/defer
            При async - браузер продолжает анализировать страницу во время загрузки JS файла, а сам скрипт выполнится как только будет загружен. 
                <script async src="https://some-link-to-app.js"></script>. Если таких скриптов будет несколько с ключевым словом асинк, то
                они будут начинать работу по мере загрузки(какой первый загрузился тот и начинает работать) не сохраняя порядок подключения.

                В нашем случае добавив asynk в тег скрипт, этого будет достаточно что бы скрипт снова правильно отработал.


            При defer - браузер продолжает анализировать страницу, а скрипт будет ждать пока браузер закончит свою работу и отработает после этого. Скрипт
                с defer никогда не блокирует страницу и выполняется когда браузер закончит формировать ДОМ.  
                <script defer src="https://some-link-to-app.js"></script>
                Скрипты с клю. словом defer выполняются в порядке подключения(по очереди).

                В нашем примере замена асинк на дефер ничего не изменит, потому что нам подходят оба ключ слова.

            
            Не только скрипты блокируют рендеринг, браузер ждет на загрузку всех ресурсов которые находятся в аттрибутах href и src. Поэтому нужно быть
                осторожным с добавлением на страницу большого количества картинок, иконок, видео, аудио, и т.п. ресурсов которые загружаются из сети.


        
    Всё что мы обговорили называется термином - The critical rendering path (Критический путь рендеринга), а задача разработчика состоит в том чтобы
        максимально сократить продолжительность этого пути, потому что чем дольше загружается страница тем больше пользователей теряет сайт.

        HTML -> DOM  --_
                        \
        Parsing => Render Tree => Layout => Paint
                        /
        CSS -> CSSOM --`

*/}


{/*    ====    HTML 5     ====

    +++ Скелет HTML страницы

        Наиболее часто используеммые теги в ХТМЛ <div>, <span>, <ul>, <ol>, <img>, <table>, <form>.

        Базовая структура(без которой страница не может существовать) <html> <head> <body>.

        В <head> прописываются теги: 
            title   - для отображения тайтла(названия) страницы,
            style   - для встроенных ксс стилей,
            link    - для подключенных ксс стилей,
            script  - для подключенных JS файлов.




    +++ Head 

        Эл. head в первую очередь является контейнером для тех эл. которые дают дополнительную информацию про документ или его мета
            данные, + ссылки на другие ресурсы которые необходимы для того что бы документ правильно отображался или работал в
            браузере.

        Содержимое head не отображается на странице.

        Задание head - сберегать метаданные документа.

        Unicode — стандарт кодування символів, що включає знаки майже всіх письмових мов світу.

        Корисні посилання
        A simple guide to HTML <head> elements
        https://htmlhead.dev/ 



        *** <base>

            Работа с url адрессами.
            Есть две ссылки в теге бади,  
            - в одной прописан относительный путь <a href="svitlana.sikora" target="_blank">My Facebook Profile</a>,
            - в другой абсолютный <a href="https://www.facebook.com/help" target="_blank">Facebook help</a>.

            По первой ссылке мы никуда не попадем потому что браузер добавляет относительный путь svitlana.sikora к локальному 
                пути к папке с открытым файлом.
                    

            По второй происходит обычный переход https://www.facebook.com/help на страницу помощи.


            Если есть ссылка на разные фейсбук страницы как у нас, то хотелось бы каждый раз указывать только относительный путь,
                а не полный абсолютный путь, для этого можно добавить в эл. head тег base и скопировать в путь начало хтмл адресса.

                <base href="https://www.facebook.com">


            Эл. base используется для определения базового url адресса для всех относительных ссылок которые содержит документ.
                То есть теперь при клике на первую ссылку относительный путь будет прибавляться к тому который в теге base, но
                в случае со второй ссылкой, если в ней уже есть абсолютный путь, то тег base будет проигнорирован для таких ссылок.
                Этот эл. должен быть прописан в head перед всеми остальными которые обращаются к внешним ресурсам, base может быть
                только один для каждого докумета(один на один документ).


            *! Если файлы CSS или JS лежат по относительному пути(в папке проекта) то подключать их нужно ПЕРЕД base, иначе он
                    будет добавлять относительный путь к файлу к абсолютному пути и файлы просто не заработают.


            Апгрейд (англ. upgrade) — якісне поліпшення чогось.

            HTML5 — нова версія мови HTML з новими елементами, атрибутами, поведінкою. Остання еволюція стандарту, який визначає 
                    HTML.

            Аперкейс (англ. uppercase) — верхній регістр літер, або написання великими літерами.



        *** <meta>

            Метатеги в основном используются для предоставления структурированных метаданных: ключевые слова документа, описание, 
                имя автора, кодирование символов, ...

            В head может быть размещено сколько угодно метатегов. Метаданные не отображаются на странице, но они используются
                браузерами или поисковыми системами.

                
            ОБъявление кодирования символов в документах хтмл, это увиличивает скорость отображения страницы
                путем упрощения работы браузера. Когда браузер получает ответ с сервера он получает текст закодированный
                в байтах, где каждый байт или их последовательность представляет заданный символ, если у браузера нету четкой
                информации про используемое кодирование, он потратит время на попытки угадать, а в некоторых случаях это может не
                получиться. Были временя когда сосуществовали сотни кодирований символов, они были все ограничены и не могли
                вместить достаточно символов чтобы охватить все языки мира, иногда некоторых кодировок не хватало для всех букв
                одного языка. UTF-8 - универсальное кодирование символов которое сейчас используется везде и охватывает более
                100 языков.

                <meta charset="UTF-8">


            Настройка окна просмотра для мобильных устройств.
                Иногда можно встетить сайты которыми очень неудобно пользоваться на мобильных устройствах, это потому что они не
                созданы для такого(не оптимизированы). Посмотреть оптимизирован ли сайт под мобильные устройства можно открыв
                ксс файл такого сайта и поискав конструкцию с медиазапросом - @media . Если ее нету то сайт не оптимизирован.
                Но бывает и так что медиазапрос есть, а сайт отображается как на большом экране, чтобы исправить такую ситуацию
                используют тег meta с name="viewport" с обязательным аттрибутом content="width=device-width, initial-scale=1".

                Этот метатег позволяет установить наилучший размер области просмотра и ограничения масштаба для просмотра веб
                страниц на мобильных устройствах. width=device-width - устанавливает ширину области просмотра такой же как ширина
                экрана устройства, initial-scale=1 - устанавливает начальный масштаб или уровень масштабирования на 100%.
                Всегда используйте этот тег на своих страницах для удобного просмотра на моб. устройствах.

                <meta name="viewport" content="width=device-width, initial-scale=1">


            Ключевые слова и описание для поисковых систем.
                Некоторые поисковые системы используют метаданные особенно ключевые слова и описания для индексирования страниц.
                Например если бы делали страницу к этому курсу, то можно было бы добавить 3 метатега.

                Ключевые слова. Можно добавить больше, но мы остановимся на трех.
                <meta name="keywords" content="HTML, CSS, JavaScript">

                Описание - про что курс
                <meta name="description" content="Easy to understand tutorials and references on HTML, CSS, JavaScript and more...">

                Тег с информацией про автора
                <meta name="author" content="Svitlana Sikora">

                Поисковые системы часто используют для описания страницы когда она появляется в поиске ключевые слова и описание.


            Пошукові роботи — програма, що є складовою пошукової системи та призначена для перебору сторінок Інтернету з метою 
                внесення інформації про них до бази даних пошуковика.

            “Доступний веб” — це концепція, що загалом означає доступність для всіх людей, незалежно від того, з яких пристроїв 
                вони переглядають сайт/застосунок, який у них рівень здоров’я, у яких умовах вони це роблять.




    +++ HTML 5

        HTML5 - MDN
        https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5

        HTML специфікація
        https://html.spec.whatwg.org/ 

        HTML <!DOCTYPE>
        https://www.w3schools.com/tags/ref_html_dtd.asp

        HTML cheat sheet
        https://www.december.com/html/spec/HTML5-Cheat-Sheet.pdf

        HTML: interactive cheat sheet
        https://digital.com/tools/html-cheatsheet/ 


        HTML 5 - это просто ключевое слово, которое относится к новым веб технологиям. Это последняя эволюция стандарта который
            определяет HTML. Это новая версия языка HTML с новыми элементами, аттрибутами и поведением и набором технологий что
            позволяет создавать более разнообразные и мощные веб сайты и программы.

            Дополнительный набор возможностей - сюда входят технологии которые позволяют разработчикам выполнять сложные операции
            вызывая только определенный метод который уже находится в глобальной области видимости: определение геолокации, создание
            запросов к серверу, доступ к локальному хранилищу данных, построение 3д графики, и другие возможности которые
            технически не относятся к HTML. 
            
            Официальная документация определяет HTML 5 как целый набор технологий с разделением по
            группам: локальные хранилща данных, мультимедия, доступ к железу(частям компьютера), кроме этого есть разделы семантика,
            графика, стили. 
            
            Но чаще всего когда говорят HTML 5 имеют в виду последнюю эволюцию стандарта определяющего HTML - это спецификация или
            набор правил о том как браузер должен понимать и отображать хтмл код. А задание браузеров отталкиваясь от спецификации
            обеспечить поддержку новых элементов.


        Если существует стандарт HTML 5 то должны быть и предыдущие, чтобы браузер знал на каком стандарте написан сайт указывается
            первая строка в документе. Если после DOCTYPE написано html то браузер для работы с документом будет использовать
            стандарт HTML 5. Если строчку доктайп вообще не прописывать, то по умолчанию браузер будет использовать самый
            последнй стандарт. 

            <!DOCTYPE html>


            Но если нам нужно даунгрейднуть страницу к более старой версии например использовать 4ю версию, а в документе использовать
            устарелые теги например центрововку текста по середини тегом <CENTER>Some text</CENTER>, но если потом вернуть запись для
            ХТМЛ 5 то верстка не изменилась, потому что ХТМЛ 5 мы не можем отключить, а  записью на 4ю версию только говорим браузеру
            к чему ему нужно готовиться(встреча устарелых тегов) - и уменьшаем немного время загрузки страницы.

            <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">




    +++ <body>   
    
        *** Работа с текстом

            Когда ХТМЛ только появился он мог показывать только текст, гиперссылки и картинки. Теперь можно добавлять аудио, видео,
                флеш элементы, ... Но текст остался главным источником информации на страницах. поэтому с ним нужно уметь работать.


            <h1></h1>, h2, h3, h4, h5, h6 - заголовки - визуальное и логическое разделение информации по важности. Заголовки 
            используются для логического выделения текста для поисковых систем. <h1></h1> - должен быть 1 на странице. В эти теги 
            должны входить только названия разделов, для обычного выделения текста заголовок не подходит 
            (используем <b>/<strong>, <em>/<i>, <small>, <sup>,<sub>).

            <p>Текст</p> - тег параграф служит обверткой для текста.

            Лишние пробелы удаляются браузером почти из всех тегов.

            <br>(break) - служит для переноса далее следующего текста на новую строку.

            <b></b>(bold) - выделение жирным.
            <strong></strong> - выделение жирным + логический смысл для поисковых систем(сообщает что выделенный текст - важен).

            <i></i>(italic)- выделение курсивом.
            <em></em> - выделение курсивом + логический смысл для поисковых систем(сообщает что выделенный текст - важен).

            <small></small> - уменьшение текста, относительно рожительского элемента.

            <sup></sup> - делает текст надстрочным.

            <sub></sub> - делает текст подстрочным.


            показывает текст не убирая пробелы и переносы(например для кода).
                <pre>                     
                    текст
                        с отступами
                            и переносами
                </pre>


            <blockquote></blockquote> - выделение как цытаты.

            <mark></mark> - посдвечивает текст(как будто желтым маркером).
            

            Определение
                <dl> - definition list
                    <dt> - definition title
                    HTML
                    </dt>
                    <dd> - definition description
                    Hyper Text Markup Language 
                    </dd>
                </dl>
                

            <abbr title="HyperText Markup Language">HTML</abbr>  - показывает содержимое title при наведении на текст HTML
                                                                    (расшифровка аббревиатур/подсказка при наведении)

            Text Formatting tags in HTML
            https://www.scaler.com/topics/html/text-formatting-tags-in-html/ 



         *** СПИСКИ

                Списки: маркированные - <ul></ul>(unordered list) и нумерованные <ol></ol>(ordered list).  
                                        <li></li> - элемент списка(не обязательно текст - ссылки, картинки,...)

                По умолчанию кружочки, их можно изменить или убрать(list-style-type: none)
                <ul style="list-style-type: square"> - квадратики вместо кружечков.
                    <li>Текст 1</li>
                    <li>Текст 2</li>
                    <li>Текст 3</li>
                </ul>


                <ol>
                    <li>Номер 1</li>
                    <li>Номер 2</li>
                    <li>Номер 3</li>
                </ol>


                Вложенность(вкладываем в li элемент)

                <ol>
                    <li>Номер 1</li>
                    <li>Номер 2</li>
                    <li>
                        <ul>
                            <li>Текст 1</li>
                            <li>Текст 2</li>
                        </ul>
                    </li>
                </ol>



         *** ГИПЕРССЫЛКИ

            <a - ancor(якорь). href - hyper reference. Строчный элемент. 

            <a href='pages/page.html'>Переход на страницу</a> - переход на другую страницу сайта по относительному пути, когда сайт
                                                                будет на хостинге браузер будет добавлять относительный путь к
                                                                доменному адрессу сайта.

            <a href='https://www.google.com'>Google</a> - может переходить по внешней ссылке.

            <a href='google.com' target='_blank'>Google</a> - с аттрибутом target='_blank', откроет ссылку в новом окне.

            <a href='#parag'>Ссылка на параграф с айди parag</a> - переходит к элементу с заданным айди(навигация по странице).

            <a target="_top" href='#'>To top</a> - переходит к началу страницы(навигация по странице).



        *** ИЗОБРАЖЕНИЯ

            <img src='./img/cat.jpg' alt='cat'> - вставит изображение которое находится в папке img с названием cat.jpg. Если 
            картинка не загрузится тогда на ее месте будет выводится текст из alt, также этот текст помогает поисковым система 
            индексировать картинку.
            
            <img src='./img/cat.jpg' alt='cat' height='300'>

            <img src='https://www.catchat.org/image/cat.jpg'> - абсолютный путь для загрузки картинки из интернета.


            Необязательные аттрибуты(но все же рекомендуют их заполнять):

            alt(alternative) - так поисковики индексируют картинки на сайте. Если картинка не загрузится тогда на ее месте 
                               будет выводится текст.

            width и height - регулируют размер изображения. Обычно указывают только один параметр что бы изображение
            отобразилось пропорционально, также эти параметры резервируют место под картинку пока она не загрузилась, что бы не 
            ломать верстку.



        *** ТАБЛИЦЫ

            Минимально необходимые теги для таблицы(<table>, <tr> - table row(рядок), <td> - table data(ячейки в рядке)). Важно
                следить что бы <td> было одинаковое количество во всех рядках. Для помощи поисковикам разбивают на thead, tbody и
                tfoot, а также caption.


            <table>
                <caption>Основной заголовок</caption>   - название таблицы

                <thead>                                 - шапка таблицы(выделенный текст)
                    <tr>
                        <th>Заголовок столбца 1</th>
                        <th>Заголовок столбца 2</th>
                        <th>Заголовок столбца 3</th>
                        <th>Заголовок столбца 4</th>
                    </tr>
                </thead>

                <tbody>
                    <tr>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td rowspan='2'>Текст</td> - объединили 2 колонки вертикально
                    </tr>
                    <tr>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td>Текст</td>
                        эта ячейка поглощена роуспаном - удаляем её
                    </tr>
                </tbody>

                <tfoot>                          - используют редко(для выводов и коментариев)
                    <tr>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td colspan='2'>Текст</td> - объединили 2 колонки горизонтально
                        эта ячейка поглощена колспаном - удаляем её
                    </tr>
                </tfoot>
            </table>



        *** ФОРМЫ

        Форма - тег предназначенный для сбора данных и отправки их на сервер. Это единстенный хтмл эл. который может напрямую
            комуницировать с сервером. Тег foem служит оберрткой для всех остальных полей(инпутов) мы как бы создаем анкету
            которую пользователь заполняет, а мы отправим на сервер.


        Тег form оборачивает все инпуты. name - имя формы, action - адресс скрипта(сервера) который будет обрабатывать данные формы
            куда отправляем), method - каким методом передается информация(POST - защищенный(данные при передаче не видно в 
            адрессной строке), GET - передает данные в адрессной строке).


        input - не имеет закр.тега, и содержит 2 обязательных аттрибута type, name. Вид инпута определяется значением в type.
                placeholder - показывает подсказку кользователю в поле инпута.

        <label for='user_name'>Your name:</label> - Текст перед полем. Для привязки к инпуту(что бы по клику выбиралось нужное поле)
                                                    используется аттрибут for по id инпута без хештега. Если они связаны то при
                                                    клике на лейбл поле инпута становится активным.
        
        input c type="number" может содержать аттрибуты min и max в них выставляем числа меньше и больше которых не можно задавать
                            с кнопок в поле инпута(кнопки появляются только для числового инпута), а если написать число больше 
                            заданого в макс то при отправке формы будет сообщение что макс такое то число и превышать его нельзя.

        <form name='user_data' action='send.php' method='POST'> 
            <fieldset> - создает блок с обводкой вокруг элементов(выделяет инпуты в блоки)
            <legend>Personal</legend> - видимое название блока с обводкой
            
            <label for='user_name'>Your name:</label>
            <input type='text' name='user_name' placeholder='Enter your name' id='user_name' required>  - текстовое поле
            <br>
            <br>

            <label for='user_age'>Your age:</label>
            <input type='number' name='user_age' placeholder='Enter your age' id='user_age' required='true' max='5'> - числовое поле. 
                                                required - аттрибут указывает что нельзя отправлять форму без заполнения этого поля
            <br>                                            (можно указывать без значения)
            <br>
            </fieldset>

            <label for='user_password'>Your password:</label>
            <input type='password' name='user_password' placeholder='Enter your password' id='user_password'> - поле для пароля, 
            <br>                                                                                  символы закрываются звездочками.
            <br>

            <label for='male'>Male</label>
            <input type='radio' name='genre' value='male' id="male">
            <label for='female'>Female</label>
            <input type='radio' name='genre' value='female' id="female"> - радио кнопки(круг), если name одинаковый то можно выбрать                                                                                              
            <br>                                                                                                 только один из них.
            <br>

            <label for='remebmer'>Remebmer me:</label>
            <input type='checkbox' name='remebmer' id='remebmer'> - квадратик где можно ставить галочку(чекбокс).
            <br>                                                                                                
            <br>

            <select name='city'>   - выпадающий список
                <option value='Kyiv'>Kyiv</option>
                <option value='Lviv'>Lviv</option>
            </select>
            <br>                                                                                                
            <br>

            <label for='message'>Message:</label>
            <input type='textarea' name='message' id='message'>  - текстовое поле которое можно увеличивать.
            <br>                                                                                                
            <br>
            
            <input type='submit' value='Submit'> - кнопка отправки формы, value - текст в середине кнопки.
        </form>


        Есть еще много типов инпута, их можно посмотреть тут
        A deep dive into the HTML form input element
        https://blog.logrocket.com/a-deep-dive-into-the-html-form-input-element/ 

        Forms cheat sheet
        https://learn-the-web.algonquindesign.ca/topics/forms-cheat-sheet/ 



        *** БЛОЧНЫЕ И СТРОЧНЫЕ ЭЛЕМЕНТЫ        

        БЛОЧНЫЕ - которые содержат блок информации и начинаются с новой строки по умолчанию(Заголовки, параграфы, теблицы, формы).
                Занимает всю ширину страницы даже без нужного количества контента, и вытесняет следующий элемент на следующую строку.
            
        СТРОЧНЫЕ - которые размещаются один за одним в одном рядке и только при необходимости переходят в следующий(большое количества
                    контента), ширина и высота строчного элемента зависит только от его содержимого. К ним относят почти все элементы 
                    форматирования текста которые находятся в самом тексте (strong, sub, sup, гиперссылки, картинки)


        <div>текст</div>            
        <div>текст</div> - блочный элемент обвертка для любого содержимого, не имеет специального назначения. Следующий эл будет
                            на следующей строке.

        <span>Текст</span>
        <span>Текст</span> - строчный элемент. Второй span начинается сразу за первым в той же строчке, потому что занимают столько
                             места сколько нужно для отображения их содержимого(контента). span используется для выделения части 
                             текста что бы ему можно было присвоить стили отличительные от используемых на странице.



        *** СЕМАНТИКА (1.4.14) 

        Семантика - это подход к созданию веб страницы, основаный на использовании хтмл тегов в соответствии с ихним назначением.
                    Она нужна для правильного логического структурирования(разделения) документа, лучшей обработки страницы 
                    поисковиками, удобства при работе с ней программиста(более читабельный код), использование страницы людьми 
                    со слабым зрением(при использовании скринридеров(устройство или программа которая голосом читает элементы 
                    страницы) - если сайт создан семантическими тегами, то скринридеру намного легче понять где основной контент
                    для чтения или меню).


        Семантические теги

        <header> - шапка сайта, их может быть несколько, для главного блока и для верхней части какого то блока находящегося уже 
                    в main
        <footer>- подвал сайта, их может быть несколько, для главного блока и для верхней части какого то блока находящегося уже 
                    в main
        <article> - автономная композиция в документе предназначенная для независимого распространения или повторного использования
                    (статья(могут быть вложеными), запись на форуме, пост в блоге, карточка товара, комментарий).
        <aside> - определяет блок сбоку для различный рубрик/архивов, 
        <section> - самостоятельная секция/раздел который не имеет более конкретного семантического элемента, 
                    может также быть с заголовком.
        <main> - используется для основного документа, который не повторяется на других страницах сайта.
        <nav> - задает навигацию по сайту, если на странице несколько тегов со ссылками, то в нав помещают приоритетные.
        <figure> - автономный контейнер для картинки (с необязательной подписью задаваемой в теге <figcaption>).
        <summary> - для выводов.
        <time>
        <strong> - выделение жирным + логический смысл для поисковых систем(сообщает что выделенный текст - важен). 
        <em>     - выделение жирным + логический смысл для поисковых систем(сообщает что выделенный текст - важен). 


        HTML semantics cheat sheet
        https://learn-the-web.algonquindesign.ca/topics/html-semantics-cheat-sheet/ 

        W3Schools: HTML Semantic Elements
        https://www.w3schools.com/html/html5_semantic_elements.asp

        На заверщение недели про ХТМЛ 
        HTML Style Guide: https://data-flair.training/blogs/html-style-guide/

*/}

{/*    ====    ПРАКТИКА (1.4.15)     ====

    Предлагается переписать верстку сайта с использованием семантических тегов. Код сайта в 1_4_15_non-semantic. Использовали header
        для замены дива хедера. nav использовали 2 раза, для главной навигации и для боковой, боковую завернули в aside. Также в
        эсайд завернули ссылку на страницу с собаками, расположенную вроде как в статье но всетаки сбоку. В main завернули всю
        статью так как она не будет повторяться на других страницах. Внутри main статью завернули в article так как она может 
        быть автономная и распространяться. Блок с картинкой и подписью завернули в figure, а подпись в figcaption. Далее видим
        что статья состоит из 4х блоков, каждый из них  кроме последнего заворачиваем в section, последний это вывод из статья
        и его завернем в summary. Дату создания статьи мы завернем в section, а внутри span заменим на time. Нижний блок с
        информацией оборачиваем в footer.

    Важно придерживаться одного стиля для всего документа, если решили делать хедер для одного блока находящегося в main, то
        делаем для всех. Если не нашли семантический тег для определенного элемента, только тогда заворачиваем его в span.

    <header>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header

    <nav>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav

    <aside>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside

    <main>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main

    <article>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article

    <figure>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure

    <section>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section

    <summary>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary 

    <time>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time 

*/}




    //==============================================  ВТОРАЯ НЕДЕЛЯ ===============================================================

{/*    ====    СЕЛЕКТОРЫ И ОСНОВНЫЕ ВЕЛИЧИНЫ CSS    ====

    +++ Вступление (2.1.1, 2.1.2)

        CSS-селектори (англ. select) - частина CSS-правила, яка повідомляє браузеру, до якого елементу веб-сторінки буде застосований 
            CSS стиль. Тобто, селектор - це вибірка та формальний опис того елемента чи групи елементів, до яких будуть застосовані
            CSS стилі.

        CSS содержит очень много параметров которые можно использовать но это не значит что нужно знать их все и сразу. Те которыми
            будем пользоваться часто запомнятся, для других есть справочник.

        CSS on MDN
        https://developer.mozilla.org/en-US/docs/Web/CSS/Reference




    +++ Прості та комплексні селектори (2.1.3)

        Емуляція - це дія та ефект наслідування, тобто «наслідування» діям іншого, хоча і забезпеченого різним змістом, для 
                отримання подібних чи кращих результатів.

        Батьківський елемент - елемент з одним або декількома дочірніми елементами. Дочірній елемент відображається під 
                батьківським елементом з відступом, щоб вказати, що він є підлеглим для батьківського елемента.

        Дочірній елемент - елемент, підпорядкований іншому елементу вищого рівня (батьківському елементу).

        Відносне посилання - адреса, яка веде відлік від кореня сайту або поточного документа, наприклад, /courses-catalog/.

        Абсолютне посилання - адреса, яка починається із вказівки HTTP протоколу (зазвичай https:// або http://) і містить ім'я 
                сайту, наприклад, https://prometheus.org.ua/courses-catalog/.



        CSS selectors
        https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors?retiredLocale=uk




    +++ Псевдоселектори (2.1.4)



        Псевдокласи
        https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes

        Псевдоелементи
        https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements




    +++ Як порахувати важливість селектора (2.1.5)



    CSS Specificity
    https://css-tricks.com/specifics-on-css-specificity/




    +++ Відносні величини (2.1.6)
    


*/}


{/*    ====    ПРОСТЫЕ СВОЙСТВА CSS    ====

*/}


{/*    ====    ЭФФЕКТЫ CSS     ====

*/}




























