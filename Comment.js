    //============================================ Prometheus Front-End ===========================================================




    //==============================================  ПЕРВАЯ НЕДЕЛЯ ===============================================================

/* Роадмап фронтендера - https://roadmap.sh/roadmaps/frontend.png . Этот курс будет охватывать основы для фронтенд разработчика на 
    карте это все блоки до центрального блока - web security knowledge. Все остальное не факт что пригодится, так что нужно учить
    только то что нужно для работы в текущий момент или перспективное(для продвижения карьеры/работы над новый проектом),
    а не хвататься за все подряд, а то получится что можно знать много поверхностно. Также нужно очень много практиковаться что бы 
    теория не забывалась и получать новый опыт при разработке и дебаггинге(поиске ошибок) кода. */
         
    
{//    ====    ЭФФЕКТИВНЫЙ ПРОЦЕСС РАЗРАБОТКИ     ====

    /* Для того чтобы писать код эффективно нужно настроить и автоматизировать этот процесс. Он состоит из нескольких частей:
         1) настройка среды разработки,
         2) как искать информацию,
         3) работа с ошибками. */
    

  /*1) Настройка среды разработки:
        - выберете комфортный редактор кода, настройте его так что бы было удобно работать

        Словник
        Редактор коду — текстовий редактор для створення та редагування коду програм. Він може бути окремим додатком або вбудованим 
            в інтегроване середовище розробки (IDE).

        IDE (інтегроване середовище розробки) — редактор коду, який має більше можливостей, може працювати з допоміжними системами,
            такими як багтрекер, контроль версій і т.д.

        Плагін — модуль, який підключається до програми і дає їй додаткові можливості.

        Рефакторинг — контрольований процес покращення вашого коду, без написання нової функціональності.

        Дефолтний (англ. default) — сленгова назва, що означає “за замовчуванням”.


    2) Поиск информации:
        - MDN https://developer.mozilla.org
        - Stack Overflow https://stackoverflow.com/ - форум для программистов, можно задать вопрос если не нагуглили.
        - научитесь гуглить(правильно вводить запрос) - например если нужно найти метод который превращает строку в число, а мы не
            помним как он называется нужно загуглить - сначала пишем на каком языке(чтобы сузить область поиска) Javascript, потом
            максимально коротко пишем что мы хотим найти convert string to number. Лучше гуглить сразу на английском языке, так 
            больше шансов что информация найдется.
        - задавайте вопросы и помогайте другим.
        - практикуйтесь, выполняйте задание разными способами.


    3)(1.1.7) Работа с ошибками:
        - Если код не работает, нужно его дебажить(найти ошибку). Ошибки бывают синтаксические и логические. Про синтаксические
            зачастую браузер сделает сообщение в консоли. Если она там есть но не понятно что за ошибка, можно ее скопировать и
            загуглить.
        - Если ошибка логическая, то нужно понимать что происходит в коде, какие данные должны быть на входе или выходе из
            ф-и, какие значения должны быть присвоены переменным. Это можно сделать двумя способами: 
            а) добавить в код console.log() в нужном месте или ключевое слово debugger - он остановит выполнение ф-и в нужном 
            месте и в инспекторе можно будет просмотреть данные в данный момент, или добавить alert() - но его не рекомендуют 
            использовать, потому что если его забыть удалить то это сразу выразится в работе сайта и будет всем видно в отличие
            от консольлога.

            b)использовать инструменты дебаггинга самого браузера. Рассмотрим на примере GoogleChrome,
            Открыть инструменты разработчика можно нажав f12 или Crtl + Shift + I или нажав в правом верхнем углу 
                три точки(меню)-> другие инструменты-> инструменты разработчика.
            Откроется поле с 8ю закладками. Чаще всего используют:
       
            - Sources - вкладака используется для дэбаггинга. Тут можно видеть какие документы подключены, ставить брейкпоинты, на 
                которых браузер будет останавливать выполнение кода и анализировать данные которые приходят.
                Например выбрав JS файл видим свой код.
                
                function showText(el) {
                    if(el.previousElementSibling.clientHeight === 80){
                        el.previousElementSibling.style.height = "100%";
                        el.innerHTML= "Show less";
                    } else {
                        el.previousElementSibling.style.height = "80px";
                        el.innerHTML= "Read more...";
                    }
                И кликнув слева от него на номере строки например 2, 4, 6, потом на странице нажимаем на кнопку Read more... и
                программа останавливается сначала на 2й строке(if), наведя курсор на el в showText(el) можно увидеть информацию
                про передаваемый объект. А если нужно увидеть какие данные пришли выделяем фрагмент строки
                el.previousElementSibling.clientHeight и правой кнопкой кликаем на нем выбрав add to watch и в окне справа
                раскрывается секция watch в которой видно какой элемент и какое значение пришло. 
                *Что бы продолжать работу программы далее нужно нажать кнопку справа над панелькой "Resume script execution F8",
                тогда выполнение кода продолжится до следующего брейкпоинта строка 4(innerHTML), нажимаем еще раз и программа
                проскакивает(не останавливается на строке 6(превая строка блока else)) потому что туда код не дошел, так как
                выполнилось первое условие блока if else.

                В меню Call Stack - видим какие ф-ии сейчас выполняются, если нажать на ф-ю anonymous -  будет состояние до того
                как showText была вызвана. Если нажать на ф-ю то справа в окне Scope можно увидеть к каким переменным имеет доступ
                ф-я на текущем рядке кода  


        Корисні посилання
            
        HTML
        https://html.com/
        
        CSS
        https://css-tricks.com/
        
        JS Visualizer
        https://www.jsv9000.app/
        
        Algorithm Visualizer
        https://algorithm-visualizer.org/
        
        Git and GitHub
        https://learngitbranching.js.org/?locale=uk
        
        React Tutorial
        https://react-tutorial.app/
        
        API
        https://rapidapi.com/learn
        
        Web3
        https://www.useweb3.xyz/  */

}


{/*    ====    КАК РАБОТАЕТ WEB     ====

    +++ Как работает ИНТЕРНЕТ

        IP адреса — (Internet Protocol address) - ідентифікатор (унікальний числовий номер) мережевого рівня, який використовується 
            для адресації комп'ютерів чи пристроїв у мережах.
            
        Сервер — комп'ютер, який обслуговує всі підключені до нього персональні комп'ютери. При цьому сервер виконує свої функції і 
            завдання без участі в цьому процесі людини, тобто самостійно.

        Клієнт — апаратний або програмний компонент обчислювальної системи, що надсилає запити серверу.

        Інтернет-провайдер — компанія, яка надає доступ до інтернету.

        Роутер (маршрутизатор) — спеціалізований пристрій, який пересилає пакети між різними сегментами мережі на основі правил та 
            таблиць маршрутизації.
            
        Пакет — одиниця даних, складена в єдиний пакет, який рухається по заданому мережевому шляху.


        Интернет - может передаваться по кабелю, через спутник или моб. связь. Он дает возможность общаться между собой компьютерам 
            или устройствам которы подключены к этому кабелю/спутник/моб. связь. Сервер это копмьютер подключенный к интернет,
            на его жестких дисках хранятся страницы. У каждого сервера есть уникальный IP адресс (интернет протокол) это как у нас
            физический адресс.
            Благодаря IP адрессу компьютеры могут находить друг друга. Но поскольюку числовое представление IP адресса мы не запомним
            (57.148.46.375) мы даем серверам названия(google.com).

            У домашнего компьютера есть IP адресс, но он не является сервером, так как подключен к интернету не напрямую. Такие 
            компьютеры  называются клиентами, потому что для доступа в интернет они используют провайдера. Тоесть когда на
            дом. компе хотим зайти на свою почту на gmail.com сначала провайдер дает доступ к интернету дом.компу, потом с сервера 
            gmail загружаются страницы и потом мы можем их просмотреть на дом. компе.
             
            Когда информация(картинки, страницы, ...) путешествует по интернету то компьютеры их разбивают на небольшие части - 
            пакеты. Когда они доходят к пункту назначения(полностью загружаются) они заново собираются в заданой последовательности.
                                    
            Если два комьютера подключены к одному кабелю с интернетом, то что бы каждому приходила своя информация, они должны быть 
            подключены к роутеру(маршрутизатору) который присвоит каждому компу свой IP адресс. На пути следования запроса от дом. 
            компа к серверу может быть много роутеров и каждый перед отправкой запроса дальше добавляет к нему свой IP как обвертку.
            Таких обверток может быть около 20 ти пока запрос дойдет до сервера, потом сервер формирует ответ и добавляет  эти IP 
            адресса обертки в том же количестве и порядке как они к нему пришли. А когда информация будет идти назад к комьютеру,
            каждый роутер будет забирать свою обертку IP при отправке информации дальше к пользователю.
            
            
        Разница интернета и веба(www)
            Интернет это - сеть, возможность компьютеров соединятся друг с другом. В этом процессе web(всемирная паутина) - может и
                не принимать участия.

            Всемирная паутина(web) - это страницы которым мы видим используя приборы которые находяться в сети, то есть это коллекция 
                информации к которой мы имеем доступ благодаря интернету.
                
            Интернет это как дороги которые соединяют города, а web(всемирная паутина) - это здания или магазины которые находятся 
                возле дороги. Чтобы зайти в магазин - нужно пройти по дороге. Чтобы получить доступ к web нужно воспользоваться
                интернетом.

        Як працює WWW та браузер (базовий курс)
        https://courses.prometheus.org.ua/courses/course-v1:LITS+114+2022_T2/courseware/b52fdaef66554d7cbb90805509f00c03/765e604d9d1746ff84301b1d165ce2ae/?child=first 

        How Does the Internet Work?
        https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm




    +++ Как работает WEB(WWW - world wide web)

        Словник
        Інспектувати код — перевіряти код програми, не лише для виявлення помилок, а й для покращення загальної якості програмного 
            коду.

        IPv4 — четверта версія інтернет-протоколу (IP), яка використовує 32-бітові (чотирьохбайтні) адреси, що обмежують адресний 
            простір. Формою запису IPv4-адреси є запис як чотирьох десяткових чисел (від 0 до 255), розділених точками. Через дріб
            вказується довжина маски підмережі.
            Наприклад: 172.16.254.1

        IPv6 — 
        нова версія інтернет-протоколу (IP), покликана вирішити проблеми, з якими зіткнулася попередня версія (IPv4). Довжина адреси
        IPv6 становить 128 біт. В IPv6-адресі записами є вісім 16-бітних блоків, розділених двокрапками.
        Наприклад: 2001:0db8:0000:0000:0000:8a2e:0370:7334

        Кеш (англ. cache) — особлива швидкісна пам'ять або частина оперативної пам'яті, де зберігаються копії часто використовуваних 
            даних. 

        Закешовані дані (англ. cached data) — колекція даних, що дублюють початкові значення, збережені в іншому місці на вашому 
            пристрої, зазвичай для полегшення доступу.
            
        Система доменних імен - DNS (англ. Domain Name System) — комп'ютерна розподілена система для отримання інформації про домени.
            Найчастіше використовується для отримання IP-адреси за ім'ям хоста.
            
        Запит (англ. request) — запит до сервера, який його обробляє.

        Відповідь (англ. response) — відповідь, яку повертає сервер.

        Headers — спеціальні параметри, які несуть певну службову інформацію про з'єднання HTTP.

        Фреймворк (англ. framework) — це своєрідний каркас для створення комп’ютерних програм. Фреймворк «нав’язує» розробнику певні 
            архітектурні обмеження при створенні програм.
            
        JSON (англ. JavaScript Object Notation) — текстовий формат обміну даними, що базується на JavaScript. Але при цьому формат 
            незалежний від JS може використовуватися в будь-якій мові програмування.
            
        Web Sockets — це передова технологія, яка дозволяє створювати інтерактивне з'єднання між клієнтом (браузером) та сервером для
            обміну повідомленнями у режимі реального часу.
            

        Вспомним ранее изученное в предыдущем курсе и немного углубимся в детали. Время от времени будем возвращаться к некоторым 
            частям этого видео чтобы рассмотреть их детальнее, потому что весь курс в целом построен вокруг того как работает веб,
            как браузер интерпретирует написанный код, как реагирует на события пользователя и в какой последовательности их исполняет,
            как делает запрос на сервер, получает и обрабатывает информацию от него.
            
            Начнем с самого распространенного сценария. 
            Открываем браузер вводим адресс сайта и нажимаем ентер. Сайт сохранен где-то на сервере. Нашу веб страницу сервер мог 
            сгенерировать или уже сохраненную отослать в ответ на запрос. А браузер если сильно упростить - интерпретатор,
            который получил страницу, прочитал код, пропроцессил его и отобразил на экране. Это в общех чертах, детальнее поговорим в
            следующем видео, сейчас же нам нужно понимать что страница на экране была сгенерирована на сервере и прислана в браузер
            по его запросу. Важный вопрос на этом этапе - откуда сервер знает что мы обращаемся именно к нему когда вводим адресс 
            сайта  - потому что серверов очень много. Официальный адресс сайта - это IP адресс.
            IP - internet protocol, он выглядит так IPv4 172.16.254.1 или в современном виде немного сложнее 2001:0db8:0000:0000:0000:8a2e:0370:7334
            - IPv6. Конечно такие числа нам трудно запомнить и каждый раз вводить их неудобно(хотя и можем).

            Первое что делает браузер когда мы ввели доменное имя и нажали энтер - превращает доменное имя в IP адресс. Сначала 
            браузер смотрит в свои захешированные данные, если мы уже посещали этот сайт то IP адресс хранится в них.
            Если не посещали, тогда браузер обращается к DNS(Domen name system - система доменных имен) серверу - это большой 
            справочник где каждому доменному имени присвоен свой IP адресс.
            ДНС сервер превращает дом. имя в IP адресс и отсылает назад браузеру и уже по IP адресс браузер обращается к веб серверу.
            Веб сервер в ответ на запрос браузера посылает ему готовую или вновь сгенерированную страницу.
            Браузер получив такую страницу знает что делать дальше и как ее обработать.

            Часть где мы вводим url адресс в адрессную строку называется - request(запрос). Браузер делает запрос к веб серверу за конкретной
            информацией. request(запрос) - это набор данных где url адресс только часть данных. Можно открыть панель управления разработчика
            -> вкладку Network(нажать на строку во вкладке name) и просмотреть детали запроса. Сюдаже входит и тип запроса request method. 
            Для получения информации(GET)и сохранения информации на сервере(POST) используют разные типа запросов, их мы рассмотрим дальше в курсе.
            Запрос может содержать meta(мета) данные - которые мы называем хедерами(response headers) - это дополнительная информация как для
            сервера так и для браузера. Всё что браузер получает в ответ на свой запрос называется - response(вкладка тут же). Традиционно на
            первый запрос браузер получает index.html - страницу, которая содержит хтмл код который браузер процессит и отображает на экране.



        *** Примененные технологии.
            Разобрались с процессом, теперь посмотрим какие технологии применяются на каждом этапе. 
            
            Всё что мы видим на экране - результат взаимодействия 3х технологий: HTML(язык разметки - отвечает за структуру сайта,  за то где и какие
            эл. должны размещаться, браузер понимает хтмл потому что это стандартизированный язык), CSS(создает хороший внешний вид сайта),
            JavaScript(логика и динамика сайта -  если сайт должен реагировать на действия пользователя, отправлять данные формы или выполнять любое 
            другое взаимодействие с пользователем). 

            Вся эта передача данных тоже стандартизирована, например какой вид должен быть у request(запрос) и response(ответ). Вид определяется
            технологией которая при этом применяется, например HTTP - hypertext transport protocol, также есть еще стандарт HTTPS - hypertext transport 
            protocol secure - это тоже самое но в зашифрованой форме. Все современныйе сайта используют HTTPS, поэтому данные отправляемые на сервер и
            получаемые с него зашифрованы, а значит защищены, только браузер и сервер обмениваются между собой специальными ключами благодаря которым
            могут расшифровать данные отдельно на стороне браузера или на строне сервера. Но пока данные в процессе передачи - они зашифрованы, и если
            кто-то перехватит нашу транзакцию(а такое технически возможно) он получит только набор непонятных символов, а не посылаемые данные.

            Для того чтобы страницу можно было генерировать на сервере используются серверные языки программирования: php, node.js, python, java или
            фреймворки на основе этих языков программирования(джанго...). Простыми словами фреймворки - это наборы вспомогательных инструментов которые
            упрощают процесс разработки, то есть не нужно каждый раз изобретать колесо и сосредотачиваться на деталях разработки, фреймворки это берут
            на себя, мы же можем сосредоточится на общей бизнес логике. Такие же фреймворки существуют и для фронтенда - react, angular, vue(коротенько
            ознакомимся с ними в конце курса).

            Так в целом работает веб. Но он намного больше чем просто хтмл код. Например мобильные приложения как например твиттер или фейсбук и данные
            которые в них приходят извне из сети, например картинки или посты которые выкладывают ваши друзья, но в этом случаем мы не получаем хтмл
            страницу в response, а только набор данных которые нужно отобразить на экране нашего приспособления(телефон/планшет). Поэтому нужно понимать
            что под словом веб подразумевается не только веб страницы, а любое взаимодействие пользовательского приспособления находящегося в сети с 
            сервером который находится далеко(не в комнате). Request/response паттерн всегда тот самый(одинаковый) разница только в формате данных которые
            пересылаются. В случае с браузером на первый запрос он получает документ в формате хтмл, но если это мобильное приложение оно получает данные
            в формате json(java script object notation) - его мы рассотрим позже на курсе. Формат данных указывается в header запроса. Если браузер получает 
            ответ формате json, то он понимает что их не нужно анализировать, парсить, отображать, а только передать в приложение и уже код написанный 
            разработчиками разберется что с этими данными дальше делать.

            Тоесть форматы данных могут быть разными, постоянная только идея обмена информацией между фронтендом и сервером и дальнейшим процессингом этой
            информации браузером или кодом приложения. Есть более прогрессивные технологии, когда браузеру не обязательно делать запрос данных, сервер
            может присылать их самостоятельно когда такие данные у него появляются браузеру при этом нужно установить постоянную связь с сервером и не 
            закрывать её(связь) и когда на сервере появятся определенные данные он их отправить автоматически - такая технология называется веб сокеты и на
            ее основе построены большинство онлайн игр и чатов.

            How DNS works (comics)
            https://howdns.works/ep1/
  
*/}


{/*    ====    РЕНДЕРИНГ     ====

    +++ Процесс отображения web страницы (1.3.1)

        Код браузера написан на С++. 

        С++ — мова програмування, яка представляє високорівневу мову програмування загального призначення зі статичною типізацією, що 
            підходить для створення найрізноманітніших додатків.

        Механізм рендерингу (англ. Rendering engine) — програмне забезпечення в рамках браузера, яке визначає, що показати користувачу 
            на основі отриманих файлів. Головний програмний компонент кожного браузера.

        Синтаксичний аналіз (англ. parsing) — це процес аналізу вхідної послідовності символів, з метою розбору граматичної структури 
            згідно із заданою формальною граматикою.

        Синтаксичний аналізатор (англ. parser) — це програма або частина програми, яка виконує синтаксичний аналіз.

        Алгоритм — скінченна чітка послідовність дій, спрямованих на досягнення поставленої мети або розв'язування задач певного типу.

        Рендеринг (англ. rendering) — це процес отримання зображення за допомогою комп'ютерної програми.

        Об'єктна Модель Документа (англ. Document Object Model - DOM) — структура документа, представлена у вигляді дерева.

        Об'єктна модель CSS (англ. CSS Object Model - CSSOM) — набір API-інтерфейсів, що дозволяють маніпулювати CSS з JavaScript. Це дуже 
            схоже на DOM, але для CSS, а не HTML.

        Чанк (англ. chunk) — маленький фрагмент інформації.

        Токен (англ. token) — сутності, які браузер утворює з символів

        Вузол (англ. Node) — точка, поєднана залежностями з декількома або всіма іншими. «Вузол» у цьому контексті — це просто елемент HTML. 
            "DOM" - це деревовидна структура, яка представляє HTML веб-сайту, а кожен елемент HTML є "вузлом"

        Рекурсія — процедура, у тілі якої знаходиться явне звернення до неї самої.


        Понимая логику работы браузера, то как он работает с тегами и как применяет к ним стили, что ускоряет его работу, что притормаживает,
            и вообще как он прорисовывает страницу наш мозг будет сразу заточен под написание оптимального хтмл, ксс, JS кода который без
            дополнительных задержек отработает для пользователя.

        Веб браузер - это часть програмного обеспечения которая загружает файлы из отдаленного сервера или локального диска, а в рамках браузера
            есть програмное обеспечение которое определяет что должно быть показано пользователю на основе полученных файлов - rendering engine(
            механизм рендеринга). rendering engine - главный програмный компонент каждого браузера, и разные производители браузеров могут 
            называть его по разному, потому что может быть разница в алгоритмах и способах обработки кода. Хоть есть такая разница, но этапы
            построения веб страницы мало отличаются, поэтому допустим что у нас есть один универсальным механизмом браузера. rendering engine(
            механизм рендеринга) - хоть и главная но все-таки часть браузера.

        Отправка и получение информации. Вспомним что данные пересылаемые по сети имеют вид пакетов(разделены на части/пакеты). Эти пакеты браузер
            получает небольшими частями чанками(chunk), браузер не ждет получения полной страницы, а начинает работать с тем что уже пришло. Когда
            мы написали хтмл, ксс, JS код и потом открываем хтмл файл - браузер видит необработанные байты данных, а не фактические символы которые
            мы написали. С этого момента ему нужно превратить эти необработанные байты в тот формат, который он поймет. Поскольку первым браузер
            получает index.html то с него и начинается процесс обработки Parsing(синтаксический анализ). 
            

            Браузеру нужно работать с ДОМ объектом
            (Document object model), но как его получить. Во первых необработанные байты перекодируются в символы, а они превращаются в сущности
            которые называются токенами. Обычный набор символов никак не поможет браузеру, и без процесса токенизации браузер может только отобразить
            набор символов которым мы прописали в хтмл, ксс, JS файле и это никак не будет похоже на веб страницу. Когда мы сохраняем документ
            с расширением .html => HTML мы даем сигнал браузеру что этот документ нужно интерпретировать именно как хтмл документ. Способ которым
            браузер интерпретирует этот файл заключается в синтаксическом анализе когда браузер должен распознать каждый открывающий и закрывающий 
            тег <html></html>. Синтаксический анализатор(parser) сначала находит открывающие и закр. скобки < > и понимает что между ними найдет
            название тега, и также знает набор правил которые применяются к каждому тегу. Можно представить токен как структуру данных в которой
            есть информация про определенный хтмл тег.

            После процесса токенизации браузеру нужно превратить их в ноды(объекты с определенными свойствами или сущность ДОМ) из этих нод браузер
            составляет ДОМ и создает родительско-дочерние-соседские связи между нодами, так на выходе мы получаем полноценный ДОМ с которым можно
            работать.

            Bytes(байты) => Characters(символы) => Tokens => Node(узел) => DOM
            
            Чем больше ХТМЛ файл тем дольше будет происходить парсинг, поэтому нужно не использовать лишние теги и не оборачивать информацию в теги
            без которых можно обойтись.


            Для анализа хтмл, ксс, js кода в рендер енжин используются разные парсеры. Хтмл парсер благосклонно относится к вашему коду и при
            некоторых ошибках старается отобразить хтмл страницу максимально хорошо. Разработчик может пропустить некторые закрывающие теги, если это
            не критические закр. теги то браузер может их добавить сам. Можно написать больше однотипных вложенных тегов чем позволяет норма браузера
            (она разная для разных браузеров) - браузер постарается проигнорировать лишние теги и отобразить страницу без ошибок. Также разработчик
            может добавить тег которого нету в словаре браузера, браузер запомнит его и попробует разобраться с ним позже. И так далее...
            Ксс и JS парсеры таких ошибок не прощают.

            
            Если в ХТМЛ файл добавленна ссылка на ксс файл в хед. По мере того как браузер получает данные хтмл документа и запускает процесс построения
            ДОМ дерева он находит тег link <link rel="stylesheet" href="./css/main.css"> и сразу делает запрос по ксс файлу и тоже получает в ответ
            необработанные байты, и происходит процесс похожий на тот который мы видели только вместо ДОМ складывается структура древовидная структура
            КСС обджект модел. Ксс стили применяются к элементу определенный каскадом(то как браузер понимает какие стили применить к конкретному эл.).
            Стили могут быть унаследованы от родительского элемента или непосредственно назначеными элементу - древовидная структура становится важной,
            это связанно с тем что браузер рекурсивно проходить структуру дерева ксс и определять стили которые надо применить к конкретному эл. На
            этом этапе у браузера есть две древовидные независимые структуры DOM(взаимосвязи между эл.) и CSSOM(вид элем.) теперь браузеру нужно соединить
            их в одно целое в Render Tree(дерево визуализации) - содержит информацию про всё видимое содержимое Object model на странице с конкретными
            примененными к нему ксс стилями. Если какой-то эл. был спрятан с помощью ксс например через display:none - то он не будет добавлен в
            Render Tree, так же сюда не попадет то что находится в теге head, тоесть можно сделать вывод что Render Tree - это все что пользователь видит
            на экране. Спрятанные эл. будут присутствовать в DOM но не будут в Render Tree.

            Bytes(байты) => Characters(символы) => Tokens => Node(узел) => CSSOM


            С построенным Render Tree(деревом визуализации) браузер переходит к следующему этапу - Layout. Это расчет размера и положения каждого эл. на
            странице. Это всё равно что передать всю информацию про содержимое страницы и примененные стили математику который рассчитает размер эл-тов
            и где они должны располагаться отталкиваясь от области браузера доступной для просмотра.

            HTML -> DOM  --_
                            \
            Parsing => Render Tree => Layout
                            /
            CSS -> CSSOM --`


            Когда браузер имеет полную информацию про размер и размещение эл. на странице наступает этап прорисовки и наконец пользовать может увидеть
            страницу такой, какой она была задумана.

            HTML -> DOM  --_
                            \
            Parsing => Render Tree => Layout => Paint
                            /
            CSS -> CSSOM --`
        

        Теперь представим что изменился размер окна браузера или пользователь открыл выпадающее меню, браузер должен держа в памяти ДОМ дерево, CSSOM и
            Render Tree проверить нужно ли что то добавить или удалить из рендер дерева, пересчитает размер и положение эл. еще раз и снова прорисует
            новое Render Tree. Этот процесс называется re-layout.

            Parsing => Render Tree => Layout => Paint
                                        |
                                    re-layout => re-paint


            Если же структура Render Tree не требует изменений, например изменился только цвет кнопки, тогда браузер применит необходимые стили и 
            выполнит только последний этап re-paint

            Parsing => Render Tree => Layout => Paint
                                                  |
                                               re-paint


        How Browsers Work: Behind the scenes of modern web browsers
        https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ 




    +++ Что блокирует рендеринг (1.3.2)

        Скрипт — набір команд на тій чи іншій мові програмування.

        Ресурсы которые блокируют рендеринг - к ним относится, всё что может помешать браузеру прорисовать страницу или прорисовать ее быстро.
            Что это может быть, например каждый пристойный веб сайт содержит JS код - благодаря которому можно изменять содержимое и стили страницы,
            удалять или добавлять узлы ДОМ дерева, изменять CSSOM это чудесно, но имеет свою цену.

            Рассмотрим пример в папке rendering-blocking(хтмл, ксс, Js файлы). В индекс.хтмл такой код

                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Rendering</title>
                        <link rel="stylesheet" href="main.css" />
                        <script defer type="text/javascript" src="app.js"></script>
                    </head>
                    <body>
                        <h1 id="header">How Browser Rendering Works</h1>
                        <img src="rendering.png" alt="rendering" />
                    </body>
                </html>
            
            Тут у нас есть заголовок и изображение. Также есть немного ксс стилей. body {
                background: #13B5EA;
                }

                h1 {
                text-align: center;
                }

                img {
                width: 100%;
                }

            Рассмотрим что произошло. Браузер получил байты данных ХТМЛ файла трансформировал их в символы, а потом в токены, по мере того как парсер
            попал на тег линк <link rel="stylesheet" href="main.css" /> браузер загрузил ксс файл, завершил конструирование ДОМ дерева и приступил к
            CSSOM, потом их соединил и создал render tree(дерево визуализации) и в результате его отобразил. Но Как изменятся эти шаги если мы добавим
            JS скрипт <script type="text/javascript" src="app.js"></script>. Код в JS файле будет искать id="header" и выводить его в консоль.
            
            Запомним что как только браузер наталкивается на тег script он ставит на паузу все что делал до этого и ждет пока загрузится и отработает
            скрипт, это потому что JS может изменять как ДОМ так и КССОМ. Поскольку браузер не знает что делает именно этот скрипт он употребляет меры
            безопасности полностью останавливая конструирование ДОМ вообще. 
            
            Почему это может быть плохо? Поместим скрипт перез закрывающим тегом </body>, откроем консоль и обновим страницу. Что сделал скрипт - он
            отработал, нашел тег с id="header" и вывел его в консоль. Но если поднять тег script в тег <head> и разместить после ссылки на ксс файл,
            обновить страницу, то в консоль выведется null, то есть скрипт не отработает как нужно, потому что пока выполняется скрипт, браузер остановил
            рендеринг и не создал узлы, а скрипт пытается найти узел который еще не был создан и не может. Поэтому запомним - место размещения JS скрипта
            имеет значение.

            Сейчас JS файл находится в той же папке что и хтмл файл и мы его загружаем локально(из файловой системы), но мы можем также добавить файл с JS
            кодом который нужно будет загрузить через интернет. Если интернет слабый, то браузер будет еще ждать пока загрузится файл, потом ждать когда
            скрипт выполнится и только потом продолжит рендеринг, это могут быть большие потери продуктивности. По умолчанию каждый скрипт - это блокер
            для парсера, но можно изменить поведение по умолчанию. Это делается при помощи ключевых слов async/defer.

            async/defer
            При async - браузер продолжает анализировать страницу во время загрузки JS файла, а сам скрипт выполнится как только будет загружен. 
                <script async src="https://some-link-to-app.js"></script>. Если таких скриптов будет несколько с ключевым словом асинк, то
                они будут начинать работу по мере загрузки(какой первый загрузился тот и начинает работать) не сохраняя порядок подключения.

                В нашем случае добавив asynk в тег скрипт, этого будет достаточно что бы скрипт снова правильно отработал.


            При defer - браузер продолжает анализировать страницу, а скрипт будет ждать пока браузер закончит свою работу и отработает после этого. Скрипт
                с defer никогда не блокирует страницу и выполняется когда браузер закончит формировать ДОМ.  
                <script defer src="https://some-link-to-app.js"></script>
                Скрипты с клю. словом defer выполняются в порядке подключения(по очереди).

                В нашем примере замена асинк на дефер ничего не изменит, потому что нам подходят оба ключ слова.

            
            Не только скрипты блокируют рендеринг, браузер ждет на загрузку всех ресурсов которые находятся в аттрибутах href и src. Поэтому нужно быть
                осторожным с добавлением на страницу большого количества картинок, иконок, видео, аудио, и т.п. ресурсов которые загружаются из сети.


        
    Всё что мы обговорили называется термином - The critical rendering path (Критический путь рендеринга), а задача разработчика состоит в том чтобы
        максимально сократить продолжительность этого пути, потому что чем дольше загружается страница тем больше пользователей теряет сайт.

        HTML -> DOM  --_
                        \
        Parsing => Render Tree => Layout => Paint
                        /
        CSS -> CSSOM --`

*/}


{/*    ====    HTML 5     ====

    +++ Скелет HTML страницы

        Наиболее часто используеммые теги в ХТМЛ <div>, <span>, <ul>, <ol>, <img>, <table>, <form>.

        Базовая структура(без которой страница не может существовать) <html> <head> <body>.

        В <head> прописываются теги: 
            title   - для отображения тайтла(названия) страницы,
            style   - для встроенных ксс стилей,
            link    - для подключенных ксс стилей,
            script  - для подключенных JS файлов.




    +++ Head 

        Эл. head в первую очередь является контейнером для тех эл. которые дают дополнительную информацию про документ или его мета
            данные, + ссылки на другие ресурсы которые необходимы для того что бы документ правильно отображался или работал в
            браузере.

        Содержимое head не отображается на странице.

        Задание head - сберегать метаданные документа.

        Unicode — стандарт кодування символів, що включає знаки майже всіх письмових мов світу.

        Корисні посилання
        A simple guide to HTML <head> elements
        https://htmlhead.dev/ 



        *** <base>

            Работа с url адрессами.
            Есть две ссылки в теге бади,  
            - в одной прописан относительный путь <a href="svitlana.sikora" target="_blank">My Facebook Profile</a>,
            - в другой абсолютный <a href="https://www.facebook.com/help" target="_blank">Facebook help</a>.

            По первой ссылке мы никуда не попадем потому что браузер добавляет относительный путь svitlana.sikora к локальному 
                пути к папке с открытым файлом.
                    

            По второй происходит обычный переход https://www.facebook.com/help на страницу помощи.


            Если есть ссылка на разные фейсбук страницы как у нас, то хотелось бы каждый раз указывать только относительный путь,
                а не полный абсолютный путь, для этого можно добавить в эл. head тег base и скопировать в путь начало хтмл адресса.

                <base href="https://www.facebook.com">


            Эл. base используется для определения базового url адресса для всех относительных ссылок которые содержит документ.
                То есть теперь при клике на первую ссылку относительный путь будет прибавляться к тому который в теге base, но
                в случае со второй ссылкой, если в ней уже есть абсолютный путь, то тег base будет проигнорирован для таких ссылок.
                Этот эл. должен быть прописан в head перед всеми остальными которые обращаются к внешним ресурсам, base может быть
                только один для каждого докумета(один на один документ).


            *! Если файлы CSS или JS лежат по относительному пути(в папке проекта) то подключать их нужно ПЕРЕД base, иначе он
                    будет добавлять относительный путь к файлу к абсолютному пути и файлы просто не заработают.


            Апгрейд (англ. upgrade) — якісне поліпшення чогось.

            HTML5 — нова версія мови HTML з новими елементами, атрибутами, поведінкою. Остання еволюція стандарту, який визначає 
                    HTML.

            Аперкейс (англ. uppercase) — верхній регістр літер, або написання великими літерами.



        *** <meta>

            Метатеги в основном используются для предоставления структурированных метаданных: ключевые слова документа, описание, 
                имя автора, кодирование символов, ...

            В head может быть размещено сколько угодно метатегов. Метаданные не отображаются на странице, но они используются
                браузерами или поисковыми системами.

                
            ОБъявление кодирования символов в документах хтмл, это увиличивает скорость отображения страницы
                путем упрощения работы браузера. Когда браузер получает ответ с сервера он получает текст закодированный
                в байтах, где каждый байт или их последовательность представляет заданный символ, если у браузера нету четкой
                информации про используемое кодирование, он потратит время на попытки угадать, а в некоторых случаях это может не
                получиться. Были временя когда сосуществовали сотни кодирований символов, они были все ограничены и не могли
                вместить достаточно символов чтобы охватить все языки мира, иногда некоторых кодировок не хватало для всех букв
                одного языка. UTF-8 - универсальное кодирование символов которое сейчас используется везде и охватывает более
                100 языков.

                <meta charset="UTF-8">


            Настройка окна просмотра для мобильных устройств.
                Иногда можно встетить сайты которыми очень неудобно пользоваться на мобильных устройствах, это потому что они не
                созданы для такого(не оптимизированы). Посмотреть оптимизирован ли сайт под мобильные устройства можно открыв
                ксс файл такого сайта и поискав конструкцию с медиазапросом - @media . Если ее нету то сайт не оптимизирован.
                Но бывает и так что медиазапрос есть, а сайт отображается как на большом экране, чтобы исправить такую ситуацию
                используют тег meta с name="viewport" с обязательным аттрибутом content="width=device-width, initial-scale=1".

                Этот метатег позволяет установить наилучший размер области просмотра и ограничения масштаба для просмотра веб
                страниц на мобильных устройствах. width=device-width - устанавливает ширину области просмотра такой же как ширина
                экрана устройства, initial-scale=1 - устанавливает начальный масштаб или уровень масштабирования на 100%.
                Всегда используйте этот тег на своих страницах для удобного просмотра на моб. устройствах.

                <meta name="viewport" content="width=device-width, initial-scale=1">


            Ключевые слова и описание для поисковых систем.
                Некоторые поисковые системы используют метаданные особенно ключевые слова и описания для индексирования страниц.
                Например если бы делали страницу к этому курсу, то можно было бы добавить 3 метатега.

                Ключевые слова. Можно добавить больше, но мы остановимся на трех.
                <meta name="keywords" content="HTML, CSS, JavaScript">

                Описание - про что курс
                <meta name="description" content="Easy to understand tutorials and references on HTML, CSS, JavaScript and more...">

                Тег с информацией про автора
                <meta name="author" content="Svitlana Sikora">

                Поисковые системы часто используют для описания страницы когда она появляется в поиске ключевые слова и описание.


            Пошукові роботи — програма, що є складовою пошукової системи та призначена для перебору сторінок Інтернету з метою 
                внесення інформації про них до бази даних пошуковика.

            “Доступний веб” — це концепція, що загалом означає доступність для всіх людей, незалежно від того, з яких пристроїв 
                вони переглядають сайт/застосунок, який у них рівень здоров’я, у яких умовах вони це роблять.




    +++ HTML 5

        HTML5 - MDN
        https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5

        HTML специфікація
        https://html.spec.whatwg.org/ 

        HTML <!DOCTYPE>
        https://www.w3schools.com/tags/ref_html_dtd.asp

        HTML cheat sheet
        https://www.december.com/html/spec/HTML5-Cheat-Sheet.pdf

        HTML: interactive cheat sheet
        https://digital.com/tools/html-cheatsheet/ 


        HTML 5 - это просто ключевое слово, которое относится к новым веб технологиям. Это последняя эволюция стандарта который
            определяет HTML. Это новая версия языка HTML с новыми элементами, аттрибутами и поведением и набором технологий что
            позволяет создавать более разнообразные и мощные веб сайты и программы.

            Дополнительный набор возможностей - сюда входят технологии которые позволяют разработчикам выполнять сложные операции
            вызывая только определенный метод который уже находится в глобальной области видимости: определение геолокации, создание
            запросов к серверу, доступ к локальному хранилищу данных, построение 3д графики, и другие возможности которые
            технически не относятся к HTML. 
            
            Официальная документация определяет HTML 5 как целый набор технологий с разделением по
            группам: локальные хранилща данных, мультимедия, доступ к железу(частям компьютера), кроме этого есть разделы семантика,
            графика, стили. 
            
            Но чаще всего когда говорят HTML 5 имеют в виду последнюю эволюцию стандарта определяющего HTML - это спецификация или
            набор правил о том как браузер должен понимать и отображать хтмл код. А задание браузеров отталкиваясь от спецификации
            обеспечить поддержку новых элементов.


        Если существует стандарт HTML 5 то должны быть и предыдущие, чтобы браузер знал на каком стандарте написан сайт указывается
            первая строка в документе. Если после DOCTYPE написано html то браузер для работы с документом будет использовать
            стандарт HTML 5. Если строчку доктайп вообще не прописывать, то по умолчанию браузер будет использовать самый
            последнй стандарт. 

            <!DOCTYPE html>


            Но если нам нужно даунгрейднуть страницу к более старой версии например использовать 4ю версию, а в документе использовать
            устарелые теги например центрововку текста по середини тегом <CENTER>Some text</CENTER>, но если потом вернуть запись для
            ХТМЛ 5 то верстка не изменилась, потому что ХТМЛ 5 мы не можем отключить, а  записью на 4ю версию только говорим браузеру
            к чему ему нужно готовиться(встреча устарелых тегов) - и уменьшаем немного время загрузки страницы.

            <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">




    +++ <body>   
    
        *** Работа с текстом

            Когда ХТМЛ только появился он мог показывать только текст, гиперссылки и картинки. Теперь можно добавлять аудио, видео,
                флеш элементы, ... Но текст остался главным источником информации на страницах. поэтому с ним нужно уметь работать.


            <h1></h1>, h2, h3, h4, h5, h6 - заголовки - визуальное и логическое разделение информации по важности. Заголовки 
            используются для логического выделения текста для поисковых систем. <h1></h1> - должен быть 1 на странице. В эти теги 
            должны входить только названия разделов, для обычного выделения текста заголовок не подходит 
            (используем <b>/<strong>, <em>/<i>, <small>, <sup>,<sub>).

            <p>Текст</p> - тег параграф служит обверткой для текста.

            Лишние пробелы удаляются браузером почти из всех тегов.

            <br>(break) - служит для переноса далее следующего текста на новую строку.

            <b></b>(bold) - выделение жирным.
            <strong></strong> - выделение жирным + логический смысл для поисковых систем(сообщает что выделенный текст - важен).

            <i></i>(italic)- выделение курсивом.
            <em></em> - выделение курсивом + логический смысл для поисковых систем(сообщает что выделенный текст - важен).

            <small></small> - уменьшение текста, относительно рожительского элемента.

            <sup></sup> - делает текст надстрочным.

            <sub></sub> - делает текст подстрочным.


            показывает текст не убирая пробелы и переносы(например для кода).
                <pre>                     
                    текст
                        с отступами
                            и переносами
                </pre>


            <blockquote></blockquote> - выделение как цытаты.

            <mark></mark> - посдвечивает текст(как будто желтым маркером).
            

            Определение
                <dl> - definition list
                    <dt> - definition title
                    HTML
                    </dt>
                    <dd> - definition description
                    Hyper Text Markup Language 
                    </dd>
                </dl>
                

            <abbr title="HyperText Markup Language">HTML</abbr>  - показывает содержимое title при наведении на текст HTML
                                                                    (расшифровка аббревиатур/подсказка при наведении)

            Text Formatting tags in HTML
            https://www.scaler.com/topics/html/text-formatting-tags-in-html/ 



         *** СПИСКИ

                Списки: маркированные - <ul></ul>(unordered list) и нумерованные <ol></ol>(ordered list).  
                                        <li></li> - элемент списка(не обязательно текст - ссылки, картинки,...)

                По умолчанию кружочки, их можно изменить или убрать(list-style-type: none)
                <ul style="list-style-type: square"> - квадратики вместо кружечков.
                    <li>Текст 1</li>
                    <li>Текст 2</li>
                    <li>Текст 3</li>
                </ul>


                <ol>
                    <li>Номер 1</li>
                    <li>Номер 2</li>
                    <li>Номер 3</li>
                </ol>


                Вложенность(вкладываем в li элемент)

                <ol>
                    <li>Номер 1</li>
                    <li>Номер 2</li>
                    <li>
                        <ul>
                            <li>Текст 1</li>
                            <li>Текст 2</li>
                        </ul>
                    </li>
                </ol>



         *** ГИПЕРССЫЛКИ

            <a - ancor(якорь). href - hyper reference. Строчный элемент. 

            <a href='pages/page.html'>Переход на страницу</a> - переход на другую страницу сайта по относительному пути, когда сайт
                                                                будет на хостинге браузер будет добавлять относительный путь к
                                                                доменному адрессу сайта.

            <a href='https://www.google.com'>Google</a> - может переходить по внешней ссылке.

            <a href='google.com' target='_blank'>Google</a> - с аттрибутом target='_blank', откроет ссылку в новом окне.

            <a href='#parag'>Ссылка на параграф с айди parag</a> - переходит к элементу с заданным айди(навигация по странице).

            <a target="_top" href='#'>To top</a> - переходит к началу страницы(навигация по странице).



        *** ИЗОБРАЖЕНИЯ

            <img src='./img/cat.jpg' alt='cat'> - вставит изображение которое находится в папке img с названием cat.jpg. Если 
            картинка не загрузится тогда на ее месте будет выводится текст из alt, также этот текст помогает поисковым система 
            индексировать картинку.
            
            <img src='./img/cat.jpg' alt='cat' height='300'>

            <img src='https://www.catchat.org/image/cat.jpg'> - абсолютный путь для загрузки картинки из интернета.


            Необязательные аттрибуты(но все же рекомендуют их заполнять):

            alt(alternative) - так поисковики индексируют картинки на сайте. Если картинка не загрузится тогда на ее месте 
                               будет выводится текст.

            width и height - регулируют размер изображения. Обычно указывают только один параметр что бы изображение
            отобразилось пропорционально, также эти параметры резервируют место под картинку пока она не загрузилась, что бы не 
            ломать верстку.



        *** ТАБЛИЦЫ

            Минимально необходимые теги для таблицы(<table>, <tr> - table row(рядок), <td> - table data(ячейки в рядке)). Важно
                следить что бы <td> было одинаковое количество во всех рядках. Для помощи поисковикам разбивают на thead, tbody и
                tfoot, а также caption.


            <table>
                <caption>Основной заголовок</caption>   - название таблицы

                <thead>                                 - шапка таблицы(выделенный текст)
                    <tr>
                        <th>Заголовок столбца 1</th>
                        <th>Заголовок столбца 2</th>
                        <th>Заголовок столбца 3</th>
                        <th>Заголовок столбца 4</th>
                    </tr>
                </thead>

                <tbody>
                    <tr>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td rowspan='2'>Текст</td> - объединили 2 колонки вертикально
                    </tr>
                    <tr>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td>Текст</td>
                        эта ячейка поглощена роуспаном - удаляем её
                    </tr>
                </tbody>

                <tfoot>                          - используют редко(для выводов и коментариев)
                    <tr>
                        <td>Текст</td>
                        <td>Текст</td>
                        <td colspan='2'>Текст</td> - объединили 2 колонки горизонтально
                        эта ячейка поглощена колспаном - удаляем её
                    </tr>
                </tfoot>
            </table>



        *** ФОРМЫ

        Форма - тег предназначенный для сбора данных и отправки их на сервер. Это единстенный хтмл эл. который может напрямую
            комуницировать с сервером. Тег foem служит оберрткой для всех остальных полей(инпутов) мы как бы создаем анкету
            которую пользователь заполняет, а мы отправим на сервер.


        Тег form оборачивает все инпуты. name - имя формы, action - адресс скрипта(сервера) который будет обрабатывать данные формы
            куда отправляем), method - каким методом передается информация(POST - защищенный(данные при передаче не видно в 
            адрессной строке), GET - передает данные в адрессной строке).


        input - не имеет закр.тега, и содержит 2 обязательных аттрибута type, name. Вид инпута определяется значением в type.
                placeholder - показывает подсказку кользователю в поле инпута.

        <label for='user_name'>Your name:</label> - Текст перед полем. Для привязки к инпуту(что бы по клику выбиралось нужное поле)
                                                    используется аттрибут for по id инпута без хештега. Если они связаны то при
                                                    клике на лейбл поле инпута становится активным.
        
        input c type="number" может содержать аттрибуты min и max в них выставляем числа меньше и больше которых не можно задавать
                            с кнопок в поле инпута(кнопки появляются только для числового инпута), а если написать число больше 
                            заданого в макс то при отправке формы будет сообщение что макс такое то число и превышать его нельзя.

        <form name='user_data' action='send.php' method='POST'> 
            <fieldset> - создает блок с обводкой вокруг элементов(выделяет инпуты в блоки)
            <legend>Personal</legend> - видимое название блока с обводкой
            
            <label for='user_name'>Your name:</label>
            <input type='text' name='user_name' placeholder='Enter your name' id='user_name' required>  - текстовое поле
            <br>
            <br>

            <label for='user_age'>Your age:</label>
            <input type='number' name='user_age' placeholder='Enter your age' id='user_age' required='true' max='5'> - числовое поле. 
                                                required - аттрибут указывает что нельзя отправлять форму без заполнения этого поля
            <br>                                            (можно указывать без значения)
            <br>
            </fieldset>

            <label for='user_password'>Your password:</label>
            <input type='password' name='user_password' placeholder='Enter your password' id='user_password'> - поле для пароля, 
            <br>                                                                                  символы закрываются звездочками.
            <br>

            <label for='male'>Male</label>
            <input type='radio' name='genre' value='male' id="male">
            <label for='female'>Female</label>
            <input type='radio' name='genre' value='female' id="female"> - радио кнопки(круг), если name одинаковый то можно выбрать                                                                                              
            <br>                                                                                                 только один из них.
            <br>

            <label for='remebmer'>Remebmer me:</label>
            <input type='checkbox' name='remebmer' id='remebmer'> - квадратик где можно ставить галочку(чекбокс).
            <br>                                                                                                
            <br>

            <select name='city'>   - выпадающий список
                <option value='Kyiv'>Kyiv</option>
                <option value='Lviv'>Lviv</option>
            </select>
            <br>                                                                                                
            <br>

            <label for='message'>Message:</label>
            <input type='textarea' name='message' id='message'>  - текстовое поле которое можно увеличивать.
            <br>                                                                                                
            <br>
            
            <input type='submit' value='Submit'> - кнопка отправки формы, value - текст в середине кнопки.
        </form>


        Есть еще много типов инпута, их можно посмотреть тут
        A deep dive into the HTML form input element
        https://blog.logrocket.com/a-deep-dive-into-the-html-form-input-element/ 

        Forms cheat sheet
        https://learn-the-web.algonquindesign.ca/topics/forms-cheat-sheet/ 



        *** БЛОЧНЫЕ И СТРОЧНЫЕ ЭЛЕМЕНТЫ        

        БЛОЧНЫЕ - которые содержат блок информации и начинаются с новой строки по умолчанию(Заголовки, параграфы, таблицы, формы).
                Занимает всю ширину страницы даже без нужного количества контента, и вытесняет следующий элемент на следующую строку.
            
        СТРОЧНЫЕ - которые размещаются один за одним в одном рядке и только при необходимости переходят в следующий(большое количества
                    контента), ширина и высота строчного элемента зависит только от его содержимого. К ним относят почти все элементы 
                    форматирования текста которые находятся в самом тексте (strong, sub, sup, гиперссылки, картинки)


        <div>текст</div>            
        <div>текст</div> - блочный элемент обвертка для любого содержимого, не имеет специального назначения. Следующий эл будет
                            на следующей строке.

        <span>Текст</span>
        <span>Текст</span> - строчный элемент. Второй span начинается сразу за первым в той же строчке, потому что занимают столько
                             места сколько нужно для отображения их содержимого(контента). span используется для выделения части 
                             текста что бы ему можно было присвоить стили отличительные от используемых на странице.



        *** СЕМАНТИКА (1.4.14) 

        Семантика - это подход к созданию веб страницы, основаный на использовании хтмл тегов в соответствии с ихним назначением.
                    Она нужна для правильного логического структурирования(разделения) документа, лучшей обработки страницы 
                    поисковиками, удобства при работе с ней программиста(более читабельный код), использование страницы людьми 
                    со слабым зрением(при использовании скринридеров(устройство или программа которая голосом читает элементы 
                    страницы) - если сайт создан семантическими тегами, то скринридеру намного легче понять где основной контент
                    для чтения или меню).


        Семантические теги

        <header> - шапка сайта, их может быть несколько, для главного блока и для верхней части какого то блока находящегося уже 
                    в main
        <footer>- подвал сайта, их может быть несколько, для главного блока и для верхней части какого то блока находящегося уже 
                    в main
        <article> - автономная композиция в документе предназначенная для независимого распространения или повторного использования
                    (статья(могут быть вложеными), запись на форуме, пост в блоге, карточка товара, комментарий).
        <aside> - определяет блок сбоку для различный рубрик/архивов, 
        <section> - самостоятельная секция/раздел который не имеет более конкретного семантического элемента, 
                    может также быть с заголовком.
        <main> - используется для основного документа, который не повторяется на других страницах сайта.
        <nav> - задает навигацию по сайту, если на странице несколько тегов со ссылками, то в нав помещают приоритетные.
        <figure> - автономный контейнер для картинки (с необязательной подписью задаваемой в теге <figcaption>).
        <summary> - для выводов.
        <time>
        <strong> - выделение жирным + логический смысл для поисковых систем(сообщает что выделенный текст - важен). 
        <em>     - выделение жирным + логический смысл для поисковых систем(сообщает что выделенный текст - важен). 


        HTML semantics cheat sheet
        https://learn-the-web.algonquindesign.ca/topics/html-semantics-cheat-sheet/ 

        W3Schools: HTML Semantic Elements
        https://www.w3schools.com/html/html5_semantic_elements.asp

        На заверщение недели про ХТМЛ 
        HTML Style Guide: https://data-flair.training/blogs/html-style-guide/

*/}

{/*    ====    ПРАКТИКА (1.4.15)     ====

    Предлагается переписать верстку сайта с использованием семантических тегов. Код сайта в 1_4_15_non-semantic. Использовали header
        для замены дива хедера. nav использовали 2 раза, для главной навигации и для боковой, боковую завернули в aside. Также в
        эсайд завернули ссылку на страницу с собаками, расположенную вроде как в статье но всетаки сбоку. В main завернули всю
        статью так как она не будет повторяться на других страницах. Внутри main статью завернули в article так как она может 
        быть автономная и распространяться. Блок с картинкой и подписью завернули в figure, а подпись в figcaption. Далее видим
        что статья состоит из 4х блоков, каждый из них  кроме последнего заворачиваем в section, последний это вывод из статья
        и его завернем в summary. Дату создания статьи мы завернем в section, а внутри span заменим на time. Нижний блок с
        информацией оборачиваем в footer.

    Важно придерживаться одного стиля для всего документа, если решили делать хедер для одного блока находящегося в main, то
        делаем для всех. Если не нашли семантический тег для определенного элемента, только тогда заворачиваем его в span.

    <header>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header

    <nav>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav

    <aside>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside

    <main>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main

    <article>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article

    <figure>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure

    <section>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section

    <summary>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary 

    <time>
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time 

*/}




    //==============================================  ВТОРАЯ НЕДЕЛЯ ===============================================================

{/*    ====    СЕЛЕКТОРЫ И ОСНОВНЫЕ ВЕЛИЧИНЫ CSS    ====

    +++ Вступление (2.1.1, 2.1.2)

        CSS-селектори (англ. select) - частина CSS-правила, яка повідомляє браузеру, до якого елементу веб-сторінки буде застосований 
            CSS стиль. Тобто, селектор - це вибірка та формальний опис того елемента чи групи елементів, до яких будуть застосовані
            CSS стилі.

        CSS содержит очень много параметров которые можно использовать но это не значит что нужно знать их все и сразу. Те которыми
            будем пользоваться часто запомнятся, для других есть справочник.

        CSS on MDN
        https://developer.mozilla.org/en-US/docs/Web/CSS/Reference




    +++ Прості та комплексні селектори (2.1.3)

        Емуляція - це дія та ефект наслідування, тобто «наслідування» діям іншого, хоча і забезпеченого різним змістом, для 
                отримання подібних чи кращих результатів.

        Батьківський елемент - елемент з одним або декількома дочірніми елементами. Дочірній елемент відображається під 
                батьківським елементом з відступом, щоб вказати, що він є підлеглим для батьківського елемента.

        Дочірній елемент - елемент, підпорядкований іншому елементу вищого рівня (батьківському елементу).

        Відносне посилання - адреса, яка веде відлік від кореня сайту або поточного документа, наприклад, /courses-catalog/.

        Абсолютне посилання - адреса, яка починається із вказівки HTTP протоколу (зазвичай https:// або http://) і містить ім'я 
                сайту, наприклад, https://prometheus.org.ua/courses-catalog/.



        Начиналось в ксс с того что можно было обратиться к тегу по селектору класса, тега, id. Теперь можно выбирать разные типы
            элементов или эл. в различных состояниях, имеется много опций для построения комплексных селекторов. Условно можно
            поделить селекторы на 2 большие группы:

            *** ПРОСТЫЕ(типичные) - *(универсальный селектор), span(тег), .i_am_class(класс), #i_am_id(айди).


            *** КОМПЛЕКСНЫЕ - селекторы аттрибутов, псевдоселекторы - лектор добавил к комплексным чтобы их как-то идентифицировать,
                              но не факт что все добавляют их в эту категорию. 
                
                Комплексные грубо говоря - те которые состоят из нескольких простых селекторов, но есть исключения это селекторы
                    аттрибута. Комплексные можно разделить на подгруппы:

                    1) Комплексный групповой(сгруппированный) селектор - когда для нескольких,
                        разных селекторов прописаны одинаковые стили, то такие селекторы можно сгруппировать - прописать через
                        запятую, а общие стили присвоить им один раз. Такая запись компактнее и понятнее.

                        div, section, article{color: blue;}


                    2) Дочерние - обеспечивают способ выбора элементов которые находятся один в одном, что делает их дочерними к
                        своим родительским элементам.

                        arcticle p {} - селектор потомка(выбирает все p которые в середине тега arcticle) в примере выберутся все
                                        4 тега p.

                        arcticle > p {} - прямой дочерний селектор(выбирает только прямого потомка, кроме тех которые вложены в
                                            другие теги даже в теге arcticle) в примере примениться к 1 и 4му p потому что другие
                                            вложены в теги section.

                        Пример      <p>Paragraph main</p>
                                    <article>
                                        <h1>Some header</h1>
                                        <p>Paragraph 1</p>
                                        <section>
                                            <h2>Some header</h2>
                                            <p>Paragraph 2</p>
                                        </section>
                                        <section>
                                            <h2>Some header</h2>
                                            <p>Paragraph 3</p>
                                        </section>
                                        <p>Paragraph 4</p>
                                    </article>


                    3) Родственные (селекторы соседи) - это элементы у которых общий предок, а сами элементы находятся на одном
                        уровне вложенности(section  или article и main p или h1 и p  из предыдущего примера). При записи h1 ~ p
                        выбрались все теги р находящиеся на одном уровне с тегом h1 и у которых общий родитель то есть 1 и 4й.
                        Если записать h1 + p - то выберется только тот эл. р который идет непосредственно после h1, то есть 1й.

                        h1 ~ p {color:red;}

                        h1 + p {color:red;} - выберется 1 эл. р который идет непосредственно после h1


                    4) Аттрибутов. Такой селектор называется - селектором наявности аттрибута, когда сам аттрибут или аттрибут со
                        значением указываются в квадратных скобках.

                            input[type]{padding: 10px;}

                            input[type='text']{padding: 10px;}

                            a[href*='login'] - селектор по части значения аттрибута
                            
                            a[href^='https://'] - селектор с чего начинается значение аттрибута

                            a[href$='.pdf'] - селектор чем заканчивается значение аттрибута

                            a[rel ~='tag'] - выберет эл. значение аттрибута которого точно совпадает если значений несколько и
                                            они написаны через пробел(rel="tag nofollow")

                                            rel - аттрибут определяющий взаимосвязь между текущим доументом и связанным документом.
                                                  Используется только если в теге есть аттрибут href. Поисковые системы могут 
                                                  использовать этот аттрибут что бы получить больше информации про ссылку. В rel
                                                  нельзя писать что угодно, существует список возможных значений, все значения
                                                  указываются через пробел.

                            a[lang | = "en"] - когда значение аттрибута разделено дефисом, а не пробелами, может использоваться
                                                символ вертикальной линии между название аттрибута и знаком равно.(lang="en-US").


        CSS selectors
        https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors?retiredLocale=uk




    +++ Псевдоселекторы (2.1.4)

        Как правило все селекторы КСС которые мы используем применяются к элементам которые можно увидеть в дереве или структуре
            документа. Их можно увидеть в выходном коде документа и с ними можно взаимодействовать. Но есть ряд элементов и 
            состояний элементов которые не отображаются в  дереве или структуре  документа, но с ними нужно работать.

            Например не существует конкретного эл. который можно увидеть в коде документа для первой буквы в слове, для области
            которая размещается перед элементом, кроме этого конкретными тегами мы не можем описать состояние элемента(отобразить
            ссылку по которой уже был выаолнен переход или ссылку на которую наведен курсор мыши). Для решения таких проблем
            используются псевдоклассы и псевдоэлементы.

        Псевдоклассы - селекторы которые определяют состояние уже существующих элементов которое может изменяться при определенных
            условиях. Так как эти состояния мы не видим, их можно протестировать в панели разработчика выбрав эл. во вкладке
            elements и справа возле вкладки style есть кнопка :hover нажав ее появится окно в котором приведены популярнын состояния
            и активировав галочкой какое-то состояние ниже в стилях можно видеть добавится ли дополнительный стиль или нет.

            p:hover{color:red;} - при наведении на параграф его текст окрасится красным.

            input:focus{background-color:red;} - при нажатии на поле ввода(когда оно в фокусе) фон поля изменит цвет.

            
        Псевдоэлементы - селекторы которые определяют область элемента которая сначала отсутствует в дереве документа, эта область
            создается искусственно при помощи ксс.

            *::selection{background-color:red;} - изменяется цвет при выделении текста любого текста на странице

            p::first-letter{font-size: 50px; } - размер первой буквы всех параграфов


        Отличие между ними в том что псевдоклассы - определяют именно состояние элементов которые уже есть на странице, а 
            псевдоэлементы - создают области или искусственные элементы которых сначала на странице не было, но и те и другие
            отсутствуют в выходном коде документа.

        *! В ксс не существует селекторов или комбинаций селекторов для выбора родильских элементов.        


        Псевдокласи
        https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes

        Псевдоелементи
        https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements




    +++ Як порахувати важливість селектора (2.1.5)

        Кроме того что селекторы бывают очень разные все они имеют разный приоритет(специфичность). Важность(приоритет) определяет
            какое ксс правило будет использовано браузером.

        Важность(приоритет) является причиной того что наши правила ксс не применяются к некоторым элементам хотя мы считали что
            должны примениться.

        Каждый селектор имеет место в иерархии специфики и каждому присвоено условные единицы важности. Если два селектора
            применяются к одному и томуже эл. то выигрывает тот у кого больший приоритет. Если у селекторов одинаковый приоритет
            тогда браузер применяет стили которые записаны последними(только последнее правило ксс). 
            
            Если селектор комбинированный, то применится тот у которого общее число приоритета будет больше
                article .paragraph = tag 1 + class 10 = 11
                #article .paragraph = id 100 + class 10 = 110


           '!important' - перекрывает все предыдущие стили (пишется после ксс правила) color: red !important;
            1000        - inline стили
            100         - id
            10          - class/pseudo-class/attribute
            1           - tag/pseudo-element
            0           - browser default
    

        CSS Specificity
        https://css-tricks.com/specifics-on-css-specificity/




    +++ Відносні величини (2.1.6)

        В ксс правилах используются 2 варианта величин - абсолютные(всегда одинаковые) и относительные(рассчитываются от размера
            родительского контейнера) величины.
            
        Абсолютные. 
        Сначала была одна такая величина - пиксель(точка матрицы монитора). 

        Список величин: in(inch)        - дюйм          1 дю1м = 2.54 см
                        pt(point)       - поинт(точка)  1 пункт = 1/72 дюйма
                        pc(pica)        - пика          1 пика = 12 пунктам
                        px(pixel)       - пиксель
                        cm(centimeter)  - сантиметр
                        mm(millimeter)  - миллиметр


        Относительные. 
        Сначала страницы не масштабировались в браузере и все пользовались пикселями. Но потом добавили другие единицы.
    
        100% = 1em ~ 16px ~ 14pt - это означает что если не изменить размер шрифта любых дочерних элементов, то по умолчанию
                                    в браузере он будет всегда 100%  и 1em или приблизительно(~) равен 16 пкс и 
                                    приблизительно(~) 14 пунктов.

        Список величин: %       - процент           рассчитывается относительно родительского эл.(исключая отступы по дефолту)
                        em      - Em                размер шрифта текущего эл.(зависит от родительского рассчитывается от него)
                        rem     - Root em           рассчитывается относительно размера шрифта корневого эл.
                        vw      - Viewport width    1% ширины браузера
                        vh      - Viewport height   1% высоты браузера
                        vmin    - Viewport min      1/100 меньшей стороны окна браузера
                        vmax    - Viewport max      1/100 большей стороны окна браузера
                        ex      - X-height          зависит от высоты буквы "х" в нижнем регистре
                        ch      - Ch                Рассчитывается в зависимости от символа "0" в шрифте текущего эл.

        Em и rem в основном используют для шрифтов. Если используется много вложенных тегов то в какой то момент можно потерять
            контроль над размером шрифта если пользоваться em потому что он как и % рассчитывается от родительского элемента, а
            rem рассчитывается от корневого элемента body(самого главного шрифта который не меняется).

*/}


{/*    ====    ПРОСТЫЕ СВОЙСТВА CSS    ====

    +++ Вступление (2.2.1)

        Ксс очень большая тема и мощный инструмент, с помощью которого можно делать как примитивные вещи - работа с текстом или 
        цветом, так и создавать сложные эффекты и анимации.




    +++ Властивості, які застосовуються найчастіше: Color (rgb, hsl, keyword, HEX) (2.2.2.)

        В ксс можно задавать цвет чему угодно: тексту, фону, обводке, индикатору фокуса, каждой наименьшей детали.

        По умолчанию все элементы на странице имеют черный цвет и прозрачный фон.

            label {
                color: red;                 - цвет текста
                background-color: green;    - цвет фона (можно и так background: green;)
            }

            input {
                border-color: pink;     - цвет обводки(границы)
                border-width: 5px;      - размер обводки
                outline-color: blue;    - цвет обводки когда поле активно
                caret-color: red;       - цвет мигающего индикатороа | в поле инпута когда поле активно
            }


        Форматы цветов 
            - Ключевое слово    - red, blue (браузер его парсит, понимает и отображает. Ограниченное количество цветов.)
            - HEX-код           - #121212, #a2a2a2, #ffffff (код в шестнадцатеричной системе 2 первых символа - красный, потом
                                    зеленый, синий, большее количество цветов. Можно делать сокращенную запись если символы
                                    повторяются #00ff00 -> #0f0)
            - RGB               - rgb(0, 220, 40) (rgb - red green blue, диапазон от 0 - 255)
            - HSL               - hsl(165, 100% 20%) (hls - тон, насыщенность, яркость ( hue, saturation, lightness))
            - RGBA              - rgba(0, 220, 40, 0.5) - таже система но с прозрачностью
            - HSLA              - hsla(165,100% 50%, 0.5) - таже система но с прозрачностью

              RGBA и HSLA - используются для того что бы задавать прозрачность конкретно к тому к чему применяется цвет, в отличии
                            от свойства opacity. Если задать div background-color: rgb(0, 220, 40) и opacity: .5;(50%) - сделали
                            фон более прозрачным, а opacity сделает все вложенные в этот див элементы тоже прозрачнее, и отдельно
                            потом их не отрегулируешь. А если задать цвет фона background-color: rgba(0, 220, 40, 0.5); тогда 
                            прозрачность применится только к цвету фона див и не затронет вложенные элементы.

                
        Запоминать эти комбинации цветов не нужно, можно открыть  Color Picker - выбрать цвет, а сайт покажет кодировку в разных
            системах.


        Кроме единого цвета можно задавать градиент. Чаще всего он задается для фона background, для текста тоже можно но пока 
            только в браузерах(гугл хром и сафари). На ColorZilla замечательный генератор градиентов код которых можно скопировать
            себе в ксс. Если хотите разобраться как самому сделать градиент - читаем статью A Complete Guide to CSS Gradients.


        Color Picker
        https://htmlcolorcodes.com/color-picker/ 

        ColorZilla
        https://www.colorzilla.com/gradient-editor/

        A Complete Guide to CSS Gradients
        https://css-tricks.com/a-complete-guide-to-css-gradients/ 




    +++ Background (2.2.3)

        Background - очень универсальное свойство, с его помощью мы задавали цвет фона и градиент. Но у него очень много 
            возможностей, оно отвечает за все свойства фона - цвет, изображение, область размещения, размер, метод повторения,
            вот эти свойства и последовательность в которой их стоит использовать:

            background-color        ( background-color: pink; )
            background-image        ( background-image: url('peppa.png'); ) - картинка занимает все пространство и размещается так
                                        как ей вздумается, особенно если размер эл. и фоновой картинки не совпадают. Цвет мы больше
                                        не видим потому что он остался под картинкой.
            background-position     ( background-position: center center; ) - через пробел нужно указать сначала гориз, а потом 
                                        вертикальное положение картинки (top, right, bottom, left, center), можно в px или %. При
                                        center center; - видим центральную часть картинки, при center top - верхнюю.
            background-size         ( background-size: contain; ) - по умолчанию стоит - auto. contain - заполнит все доступное
                                        пространство повторением картинки, при отмене повторения изображение разместилось по центру
                                        и мы видим его полностью. Если поменять на cover - изображение заполнит все пространство
                                        растянув картинку(сейчас видим центральную часть). Можно в px или %.
            background-repeat       ( background-repeat: no-repeat; ) - отменяет повторение картинки. (repeat-x - повторение будет
                                        только по горизонтали, repeat-y - только по вертикали, repeat - в обоих направлениях).
            background-attachment   ( background-attachment: fixed; ) (fixed, local, scroll) - отвечает за скролл изображения в
                                        середине контейнера. В контейнер добавим параграф с большим количеством текста, и пропишем
                                        overflow: auto - чтобы добавился скролл. Теперь внутри элемента появился текст который уходит
                                        вних и полоса прокрутки. При fixed - изображение растянулось как при cover и не будет 
                                        двигаться при скроле в элементе и страницы полностью. При scroll - снова какртинка вернулась
                                        к contain и теперь зафиксировалась относительно страницы и будет скролиться только вместе со
                                        страницей, а не с элементом. При local - картинку растянуло на контент и она теперь будет
                                        скролиться только со скролом элемента.
            background-origin       ( background-origin: content-box; ) - говорит где хотим прорисовывать фоновое изображение 
                                        (border-box, padding-box, content-box) - comes first. При  content-box; - означает что
                                        картинка не будет заходить на паддинги(от картинки будет пустое место паддингов до границы),
                                        если указать padding-box(значение по умолчанию) то картинка будет прорисовываться на 
                                        паддингах, при условии что у clip тоже задано padding-box, иначе картинку растянет на нужное
                                        место но края там где картинка выходит на паддинги обрежутся. ЕСли обоим задать border-box
                                        то и картинка и цвет начнут прорисовываться включая границу(border) - можно увидеть если
                                        сделать границу пунктирной(dashed).
            background-clip         ( background-clip: content-box; ) - определяет область которая будет зарисовываться фоном 
                                        (content-box, border-box, padding-box)  - comes second. При  content-box; - означает что
                                        цвет не будет заходить на паддинги(от цвета будет пустое место паддингов до границы).


            Также можно использовать универсальный параметр background, при такой записи получается меньше кода но хуже 
            читабельность, поэтому лекторо рекомендует присваивать значения полному свойству, потому что в производительности
            мы выигрывает не так уж и сильно:

                background: pink url('peppa.png') center center / contain no-repeat local content-box content-box;

                В большинстве случаев последовательность объявления этих значений не важна, но есть 2 исключения:
                    - фоновый размер должен быть объявлен сразу поле фоновой позиции и они должны быть разделены слешем
                        center center / contain
                    - origin и clip - должны сохранять порядок сначала origin, а потом clip.




    +++ TEXT (2.2.4)
        
        color: red; - цвет.


        text-align - используется для горизонтального выравнивания текста, работает только для блочных элементов (
                        center; 
                        end - если тект идет слева на право, то по правому краю и наоборот; 
                        inherit - значение от родительского эл.; 
                        initial - устанавливает значение по умолчанию; 
                        justify - выравнивание по ширине(растягивает текст и по левому и по правому краю); 
                        left; 
                        revert - возвращает значение которое предусмотрено браузером; 
                        right; 
                        start - как енд, но наоборот; 
                        unset - ищет ближайший родительский эл. с таким же свойством и берет значение из него, а если такого
                                не найдет, то применит браузерное значение, если и браузерных стилей нету, тогда применит инишиал). 

                        *! Текст элайн это параметр который не наследуется, для таких свойтсв unset ведет себя как initial.


        Больше не будем останавливаться на inherit, initial, revert, unset - у разных свойств эти значения ведут себя более менее 
            одинаково.


        text-indent - величина отступа первой строки блока текста. Допускается минусовое значение, принимает любые единицы длинны
                        принятые в ксс.


        text-decoration - добавляет оформление тексту(подчеркивание, перечеркивание, линия над текстом, мигание). Одновременно
                        можно применять до 4х стилей перечисляя значения через пробел, обязательным значение является тип линии:
                        overline        - линия над текстом;
                        line-through    - перечеркнутый;
                        underline       - линия под текстом;
                        none            - убирает все эффекты, даже подчиркивание которое есть у ссылок;

                        Выбрав тип линии ей уже можно задавать стили:
                        doted   - в точку;
                        double  - двойная;
                        dashed  - 
                        wavy    - хвыляста;

                        Далее можно указать ширину линии:
                        auto    - браузер выбирает ширину линии;
                        3px     - определенное число;

                        Последний параметр - цвет
                        purple

                        text-decoration: underline doted 3px purple;

                        Также их можно задать и отдельными параметрами:
                        text-decoration-line: underline 
                        text-decoration-thickness: 3px;
                        text-decoration-style: wavy;
                        text-decoration-color: purple;


        text-transform - для трансформации текста.
                        capitalize  - первый символ каждого слова будет заглавный;
                        lowercase   - все символы в нижнем регистре;
                        math-auto   - регистр определяется автоматически;
                        none        - не изменяет регистр(возможно защита от изменения);
                        uppercase   - все символы в верхнем регистре.


        letter-spacing - интервал между символами в данном элементе. 
                        normal - задает обычный интервал;
                        3px - принимает любые единицы длинны принятые в ксс.


        word-spacing - интервал между словами в данном элементе. Работает также как letter-spacing.


        white-space - отображение переносов между.
                        break-spaces    - последовательность переносов сберегается, включая переносы на концах рядков(строк). 
                                            Рядки переносятся по любым переносам, в том числе в середине их последовательности.
                                            Переносы занимают место и не висят на концах рядков, поэтому влияют на внутришние 
                                            размеры.
                        no-wrap         - пробелы не считаются, переносы рядков в коде хтмл игнорируются. Весь текст отображается
                                            в один рядок. Добавление тега <br> - переносит текст на новый рядок.
                        pre             - текст показывается с учетом всех пробелов и переносов в коде хтмл. Если рядок получается
                                            слишком длинным и выходит за область, то добавится горизонтальная линия прокрутки.
                        pre-line        - в тексте пробелы не считаются. Текст автоматически переносится на следующий рядок если он
                                            не помещается в заданой области.
                        pre-wrap        - сберегаются все пробелы и переносы. Текст автоматически переносится на следующий рядок 
                                            если он не помещается в заданой области.
            

        text-shadow - добавляет к тексту тень.  text-shadow: 1px 1px 2px #000;




    +++ ШРИФТ (2.2.5)

        font-size   - задает размер шрифта, кроме значений которые подсказявает браузер принимает любые допустимые единицы ксс.
                        За 100% - берется размер шрифта родительского элемента. 
                        Если в пикселях - то точно в пикселях и не зависит от родителя. 
                        font-size: 3px;

        
        font-family - семейство шрифта который будет использован. Может включать несколько шрифтов разделенных запятой.
                        Когда браузер встречает первый шрифт из списка, он проверяет шрифт на наявность на компьютере пользователя,
                        если такого нету, берется следующий. Заканчивают список обычно ключевым словом которое описывает тип
                        шрифта(начертание): serif, sans-serif, cursive, monospace, fantasy. Таким образом последовательность
                        шрифтов лучше начинать с экзотических типов и заканчивать обобщающим именем которое задает вид начертания.
                        font-family: Arial, "Times New Roman", sans-serif;

        
        При вводе font браузер выдает в подсказке много свойств с этим словом, лектор рекомендует попрактиковаться с ними чтобы
            знать за что какой отвечает.
                        



    +++ КАК ПОДКЛЮЧИТЬ СТОРОННИЕ ШРИФТЫ (2.2.6)

        Рассмотрим один из самых полезных бесплатных ресурсов - google fonts.

        Выберем шрифт, например Pacifico переходим в него. Теперь нужно выбрать одно или несколько начертаний. В этом случае есть
            только один вариант, его и выбираем клацнув на Select this style справа. 
            
            Видим что выбран способ link, ниже ссылка
            на шрифт сгенерированая сайтом, ее копируем и вставляем в head нашего сайта. Теперь шрифт можно будет использовать в
            свойстве font-family: "Pacifico", cursive; для любых дополнительных действий. Теперь назначим его тегу бади

                body { font-family: "Pacifico", cursive; }. 
            
            Видим что шрифт текста изменился. В этом случае дополнительным шрифтом
            подобран cursive, дополнительный шрифт стоит подбирать максимально похожим на основной, в данном случае гугл фонтс
            взял это на себя и сгенерировал нам такое свойство. Из плюсов такого способа - простота использования и всегда 
            актуальные версии шрифтов. Но есть и минус - запрос на внешний сервис может негативно повлиять на скорость загрузки
            страницы. Если выбираем такой способ стоит уделить внимание оптимизации.


            Для оптимизации есть альтернативный способ - хранение файлов со шрифтами вместе с остальными файлами проекта. Для
            этого нужно сначала загрузить шрифты. После клика по Select this style справа от шрифта, внизу есть кнопка download all
            Для загруженых шрифтов принято создавать отдельную директорию в корне проекта, например - fonts. В нее помещаем файлы
            для каждого шрифта в нужных форматах. Обычно разработчики шрифтов добавляют несколько их форматов для улучшения
            поддержки браузерами. У Pacifico почему-то только один формат, поэтому с ним и будем работать. Вообще шрифты можно
            загружать на разных ресурсах, при этом нужно обращать внимание на лицензию, файл OFL некоторые шрифты могут быть
            не доступны для коммерческого использования. Саму лицензию в папку fonst добавлять не нужно. После того как шрифты
            добавлены в проект их нужно подключить в ксс файле, для этого используется правило font face. В самом базовом варианте
            оно будет включать такие свойства 1) назавание шрифта(потом ее используем для задания эл-м нужный шрифт), название
            можно даже придумать свое - ont-family: "my-font"; 2) путь к файлу со шрифтом src: url("fonts/Pacifico-Regular.ttf"),
            потом указываем формат файла - format("truetype"), для расширения ttf формат truetype, для других расширений другие
            форматы, их можно найти в справочниках. Если путей для файла несколько их можно указать через запятую - pe"), ...;
            первым должен быть указан наилучший вариант пути, а потом запасные варианты.

                @font-face{
                    font-family: "my-font";
                    src: url("fonts/Pacifico-Regular.ttf") format("truetype"), ...;
                }

            Если подключаем несколько шрифтов, то для каждого нужно отдельное правило @font-face.
            
            Мы подключили шрифт, теперь можно его использовать.

                body { font-family: "my-font"; }. 


        Google Fonts
        https://fonts.google.com/

        @font-face на MDN
        https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face?retiredLocale=uk 

        How to use @font-face in CSS
        https://css-tricks.com/snippets/css/using-font-face-in-css/ 




    +++ BOX MODEL (ОТСТУПЫ) (2.2.7)

        Все что мы видим на странице состоит из блоков, они могут содержать текст, изображение, ничего не содержать или быть
            контейнером для вложенных блоков.

        В блок входит контент + паддинг + рамка(border) + марджин. Размер каждой облсти определяется своим ксс свойством и может
            быть нулевым, а в случае марджин - минусовым(негативным).

        В примере два блока див со словами One и Two. Паддинг, марджин - установлены на 0, а фонт-сайз: 40пкс для всего документа.
            При этом высота блоков сейчас = высоте контента, а ширина = весь рядок(потому что блок). 

            Добавим padding 20px - это внутренний отступ. По умолчанию его размер не входит в размер эл. Блок увеличился в высоту.
                                    Используют что бы добавить фон вокруг контента.

            Добавим border 20px solid purple - это граница. По умолчанию ее размер не входит в размер эл. Еще больше увеличился.

            Добавим margin 20px - это внешний отступ. Его размер никогда не входит в размер эл. Еще больше увеличился.
                                    Используют что бы добавить отступ между соседними элементами.

            Добавим width и height 200px - видим что эти размеры применились только к контенту.

            Если мы хотим чтобы паддинг и бордер входили в эти 200пкс, нужно добавить box-sizing: border-box;

            Паддинг, бордер, марджин можно еше разбить на верхний, правый, нижний, левый сегменты. Размер каждого независимо от
                других может управляться своим конкретным свойством.
                margin-top: 20px;
                margin-right: 30px;
                margin-bottom: 40px;
                margin-left: 10px;

                Их можно написать и в одном рядке
                margin: 20px 30px 40px 10px;

                Если margin задан у двух соседних элементов по 20пкс, то расстояние между ними будет 20пкс, потому чо margin не
                    суммируются а накладываются один на другой.

            
        Дочерние элементы не наследуют эти свойства.




    +++ FLOAT (2.2.8)

        Float - задает обтекание элемента. Чаще всего применяется для обтекания картинки текстом.

        Например есть картинка и параграф с текстом. Справа от картинки есть пустое место, его можно заполнить текстом. Зададим
            тегу img  свойство float. При этом этот элемент выбивается из общего потока документа, а все эл. которые идут после
            него в верстке могут обволакивать этот элемент.

            float: left; - картинка сместилась влево, а справа место заполнилось текстом из следующего элемента как бы обтекая
                           этот элемент.


        img это линейный элемент. Поэксперементируем с блочными. Создали 3 дива вместо img. Они встали в вертикальную линию каждый 
            прижат к левой стороне, а справа резервируется место потому что элементы блочные. Зададим float всем элементам.
            
            float: left; - теперь все три стали в линию горизонтально а оставшееся за третим блоком место заполнилось текстом из 
                           параграфа.

            !* Если нужно что бы только блоки размеситились в линию. а текст не обтекал их в этом случае для параграфа используем 
            p{
              clear: left;
            }
            Возможные значения (left, right, both)

        Раньше разработчики часто делали nav бары с помощью флоат, но теперь есть другие более лучшие инструменты, о них далее.




    +++ DISPLAY (2.2.9)

        По умолчанию:

            Блочные эл. - занимают всю ширину контейнера. На них действуют все свойства - высоста, ширина, марджин, паддинг.


            Строчные - занимают столько сколько в нем контента. Высоту и ширину строчные эл игнорируют полностью, а марджин и 
                        паддинг применяются только со сторон, сверху и снизу игнорируются.

                        Если элемент <span>I am span</span> поместить в большой текст тега
                        <p>, то можно видеть что него действует только марджин и паддинг боковые - вбока от контента блока, хотя
                        сам элемент судя по рамке(border) вокруг элемента, растянуло на паддинг, текс тега р выше и ниже 
                        контента спана продолжает проходить через элемент спан. То есть марджин и паддинг сверху и снизу 
                        игнорируются окружающими элементами. 


        В ксс свойство display может менять поведение блока. У display много значений, начнем с 4х базовых(создадим 2 эл. h1, на
            странице они разместились каждый заняв всю ширину страницы хотя контента мало, потому что они по умолчанию блочные,
            также добавим 2 линейных эл. span которые по умолчанию строчные, они разместились друг за другом в строку):
            
            display: block      - эл. ведет себя как блочный

            display: inline     - эл. ведет себя как строчный

            display: inline-block - эл. стоят в строку как строчные но при этом, не игнорируют размеры и отступы.

            display: none       - эл. останутся в ДОМ дереве но будут удалены из Рендер дерева, а на их место на странице
                                    переместятся следующие за ними.


        Коротко про остальные значения дисплей.
            
            Поддерживает табличные значения. Можно создать таблицу через <table> в хтмл, а можно с помощью div с присваиванием
            им значений display: table; table-caption, table-row, table-cell. Это может быть удобно если мы хотим отображать
            таблицу на большом экране, и через медиазапросы адаптировать ее к меньшим экранам. Раньше вся верстка была в таблицах,
            а когда ксс набрал популярности стали популярными плавающи макеты, в них контент размещали в плавающих div.


            Недавно появились гибкие макеты которые набирают популярность. Сейчас уже все браузеры поддерживают флекс и почти
                все(кроме baidu) поддерживают грид. Их мы рассмотрим дальше в курсе.
                display: flex;
                display: grid;


    Display
    https://developer.mozilla.org/en-US/docs/Web/CSS/display




    +++ POSITION (2.2.10)

        position: static,
        position: relaive,
        position: absolute

        Позиционирование производится по системе координат x,y,z. При загрузке страницы происходит рендеринг элементов (заголовков, 
        рядков, блоков...). Рендеринг происходит в той последовательности в какой встречаются элементы на странице. Позиционировани
        упорядочивает процесс отображения всех элементов на странице. Позиционирование сооющает где должен располагаться элемент и 
        как влиять на окружающие его элем.


        В ксс свойство position может принимать 5 значений:

        *static - по умолчанию все элементы позиционируются с этим значением. Каждый элемент расположен с естественным порядком
                добаления его на страницу. Элементы блоков располагаются под элементами блоков, а линейные(строковые) - один за 
                другим.


        *inherit - дочерний элемент наследует позишн от родительского.
        

        *relative - относительное позиционирование. Эти элементы располагаются относительно своей позиции. Сдвиг производится 
                    его изначальной положения. При сдвиге блока на его месте остается образ относительно которого все элементы
                    располагаются, а элемент спозиционированый накладываются на другой. Элементы с relative выходят из общего потока,
                    но ведут себя так как будто в нем находятся(сохраняя место за собой которое другие эл. не могут занять). 
                    
                    На практике два блока с картинками. При статике один находится под другим.
                    .relative {position: relative; right: 100px; top: 100px; } - блок сместился в право на 100пкс и вниз на 100пкс,
                    перекрыл собой второй блок, но второй блок остался на месте. как будто первый все еще занимает свое место в 
                    структуре.
                    ***Этот тип позиционирования не применяется к табличным элементам: столбцам, рядкам, ячейкам.
                
                    
        *absolute - этот тип позиционирования вырывает блок из общего потока(структуры) документа. Точка отсчета - эти элементы 
                    располагаются относительно ближайшего родительского элемента с позиционирование отличным от static(***НЕ static).
                    Если такого родительского эл. нету - позиционирование производится относительно основного документа, тоесть
                    элемента body. ***Для того что бы абсолютное поз. работало относительно родительского, нужно дочернему эл. 
                    прописать absolute, а родительскому relative.
                    
                    На практике
                    Три картинки в диве. Диву присвоили .relative {position: relative; border: 2px red solid;}. Картинки при этом 
                    располагаются подряд и их обворачивает контур от дива. Когда картинкам присвоим img{position:absolute;} - все 
                    три картинки сбиваются в левый верхний угол(начало) родительского дива и накладываются одна на одну, а див ведет
                    себя так как будто в нем нету картинок и схлопывает контур в одну линию, потому что без содержимого его 
                    высота = 0.
                    Если каждой картинке присвоить класс и прописать отступы, то они сместятся. .image1 {top: 10px; leaft: 10px;}
                    .image2 {top: 100px; leaft: 100px;}  .image3 {top: 200px; leaft: 200px;} - в данном случае картинки будут 
                    располагаться наискось слева сверху - вправо вниз, сама нижняя будет перекрывать уголок средней, а средняя 
                    перекроет уголок верхней, а родительски див продолжит себя вести как будто он их игнорирует.
                    Но если нам нужен обратный порядок перекрытия, нужно добавить z индекс - глубина(слой) чем больше значение, тем
                    выше элемент на странице. .image1 {top: 10px; leaft: 10px; z-index: 30;}
                    .image2 {top: 100px; leaft: 100px; z-index: 20;}  .image3 {top: 200px; leaft: 200px; z-index: 10;} - теперь
                    перекрытие начинается сверху, тоесть первая. верхняя картинка перекрывает часть второй средней, а она в свою 
                    очередь перекрывает часть третьей нижней картинки. Наибольшее значение з индекса - 9999.         


        *fixed   - фиксированное. Всегда игнорирует родительские элементы и располагается относительно окна браузера(вырывается из
                общего потока).Во время просмотра страницы элемент не смещается. Применяется для создания вкладок, меню, 
                заголовков, ... элементов которые должны бытьпостоянно видны пользователю и оторые он не может проскролить.
                
                На практике
                button {position: fixed; top: 10px; right: 10px;} - кнопка вырывыется из структуры (стояла перед всеми картинками
                    и прилягала к первой из них)будет в правом верхнем углу, перекрывать остальные элементы и не смещатся при 
                    скролле страницы, а остальные элементы займут место как будто кнопки нету в их родительском диве.
        

        *stiky  - это гибрид относительного(relative) и fixed позиционирования. Элемент рассматривается как с позиционированием
                    пока не дойдет до заданной границы.
                    
                На практике
                Есть параграф с текстом, под ним идет строка из картинок, ниже идут следующие параграфы с текстом. Когда применяем
                    к диву с картинками {stiky: fixed; top: 0px; } и начинаем скролить, картинки скролятся вместе со страницей
                    пока не дойдут до границы(относительно своего контейнера), в нашем случае - top: 0px. Как только верхняя часть
                    окна браузера дотрагивается до верхней части дива с картинками - элемент начинавет вести себя как с позицией 
                    fixed - вырывается из общего потока, останавливается в верхней части окна браузера(как будто прилипает к нему),
                    а текст который был под картинками скролится дальше, подлазя под этот див с картинками. 




    +++ СПЕЦИАЛЬНЫЕ СИМВОЛЫ (2.2.11)

        Существует множество разных псевдобукв которые могут отображаться на странице, но их нету на клавиатуре(знак копирайт,
            параграф или знаки разных валют). Когда мы вставляем их настраницу они могут отображаться не правильно. Для того чтобы
            убеддиться что они правильно отобразятся нужно использовать хтмл коды. Каждый такой символ имеет свой хтмл код, который
            нужно просто разместить в хтмл теге.
        
            Прежде чем использовать такой код, нужно удостовериться что наш документ использует правильную кодировку юникод utf-8.
            В хед документа пропишем:
            <meta charset="utf-8">


        Спеціальні символи
        https://psdtowp.net/html-codes-special-characters.html
                                
*/}


{/*    ====    ПРАКТИКА (2.2.12)    ====

    В течении курса будем работать над созданием страницы кинозала. На ней будут статические данные, минимальные эффекты, анимация.
        Кроме этого она будет адаптирована под мобильные устройства с выпадающим меню. После освоения темы JS сделаем страницу
        интерактивной с динамическими данными которые приходят с сервера.

    Пока-что начнем с минимальной верстки примитивной страницы на базе информации из предыдущих блоков занятий. Дальше будем ее
        модифицировать.

    

    Сначала анализируем дизайн.
    У нас есть шапка сайта с заголовком. Ниже функционал для соритровки фильмов, можем его рассматривать как навбар. Боковая панель
        без наполнения чтобы не тратить время(но она имеет свой размер). Главная часть со списком фильмов(пока два, две карточки)
        каждый из которых содержит свою шапку: фоновая картинка, название фильма, длительность; описание фильма; имя режисера. 
        Футер с заголовком. Весь текст название, длительность, описание фильмов пока вставляем в верстку, они будут захардкоджены,
        а потом будем получать с сервера.



    Создаем структуру проекта. В папке Project - папка img с двумя изображениями(для хедера и постера фильма), папка ксс с файлом
        style, и файл index.html

    Открываем index - добавляем базовую разметку и подключим ксс файл после тайтла 
    <link rel="stylesheet" href="./css/style.css">



    Начнем с общих стилей, потому что фон сайта черный, а весь текст - белый, укажем это вначале. Позже нужно будет рассчитать
        размер элементов чтобы правильно разместить их на странице - поэтому зададим - box-sizing: border-box; чтобы рамка и
        внутренние отступы(паддинги) входили в размер элемента.

            *{box-sizing: border-box;} - зададим каждому элементу на странице потому что оно не наследуется.

        Для бади задаем остальные стили потому что они наследуются от родителя. Стиль шрифта - хельветика, цвет фона - черный,
        цвет текста - белый, пока прописываем ключевыми словами. Также для всех эл. нужно обнулить отступы по умолчанию
        добавленные браузером. Посмотрим что вышло - откроем хтмл файл в браузере - пока видим черный фон.

            body {
                margin: 0;
                padding: 0;
                font-style: Helvetica, sans-serif;
                background-color: black;
                color: white;
            }

    

    Верстаем Хедер. Тут хватит двух элементов - сам хедер и в нем h1 - главный заголовок. Верстаем и добавляем классы. Класс h1
        назван таким способом в соответствии с методологией БЕМ.

            <header class="header">
                <h1 class="header__title">КІНОЗАЛ</h1>
            </header>

        Для доступа к h1 можно обратится как .header__title{} или как .header h1{}. В первом случае браузер просто ищет все эл.
        с классом .header__title, а во втором случаем поиск будет немного дольше, сначала браузер найдет все h1, а потом проверит
        у каких из них есть родительский эл. с классом .header , поэтому чем короче селектор тем быстрее загружается страница.

        Лектор использует такой подход к верстке: теги для структуры документа, классы для ксс стилей, id для JS кода.

        Пропишем стили в ксс. Хорошая идея будет - определиться со стандартными отступами, что бы сайт смотрелся по центру. В нашем
        случае это будет 16пкс, если нужен будет больший тогда стандартный умнижм на 2 и получаем 16 * 2= 32пкс, делаем по такой
        логике. Для задния картинки нужно сначала выйти из ксс папки ../ , а потом выбрать в какой папке находится картинка и саму
        картинку. position - ставим картинку по центру элемента, size: cover - растягиваем ее на весь элемент, так не будет пустых
        зон и повторений картинки.

            .header {
                height: 250px;
                padding: 16px;
                background-image: url('../img/header.jpg');
                background-position: center center;
                background-size: cover;
                }

                .header__title {
                    text-align: center;
                    text-transform: uppercase;
                }



    Верставем соритровку(соритровать по:  название  дата). Оборачиваем тегом нав. Кнопки соритровки обернем в ссылки(можно и 
        списком), так как href удалить нельзя, просто добавим им заглушки #.

            <nav class="sort">
                <span class="sort__label">Сортувати за:</span>
                <a class="sort__item" href="#">Назва</a>
                <a class="sort__item" href="#">Дата</a>
            </nav>
        

        Стили. Для сорт стилей пока нету, а для лейб и айтем есть общие стили, поэтому их пропишем сначала. Дисплей блок чтобы
        работали стили для блочных эл. на ссылки, но чтобы элементы были в строке. Задаем отступы сверху/снизу 0 , с боков
        двойной стандартный отступ 32пкс, высоту текста, отключаем подчеркивания у ссылок и стандартные стили от браузера
        text-decoration: none;.

            .sort__label,
            .sort__item {
                display: inline-block;
                padding: 0 32px;
                line-height: 3rem;
                text-decoration: none;
                color: white;
            }


        Также ссылки дожны реагировать на наведение - показом в низу розовой границы, а фоновый цвет становится светлее. Цвета
        лектор взял из своей заготовки.
            
            .sort__item:hover {
                background-color: #0F0D0E;
                border-bottom: solid #FF7474 5px;
            }



    Верстаем далее. Теперь нам нужно поделить страницу на 2 части: боковую панель  и основной контент. Создаем боковую панель
        aside. Основная часть будет main, а в середине 2 карточки с фильмами. Карточку заворачиваем в article. Параграфам классы
        не присваиваем потому что стилизовать не будем. Между ними будет разделительная полоса - <hr>.

            <aside class="sidebar">Найкраща в світі бокова панель</aside>

            <main class="content">
                <article class="card">
                    <header class="card__header">
                        <h2 class="card__title">Думи мої тихі</h2>
                        <span class="card__info">2019 - 1 год 34 хв</span>
                    </header>
                    <section class="card__content">
                        <p>Опис. Lorem ipsum dolor sit amet consectetur adipisicing elit. Ducimus sit soluta maiores consequatur
                        debitis animi culpa doloribus id molestias sapiente accusamus odit officiis, ullam odio inventore
                        eum vero accusantium ea?</p>
                        <hr>
                        <p>Режисер: Lorem, ipsum dolor.</p>
                    </section>
                </article>
            </main>


        Стили.
        Начнем с разделения пространства боковой панели и главного контента. Пропишем в эсайд и контент дисплей инлайн-блок,
        что-бы они разместились рядом, и зададим ширину по 25% и 75%. Переходим на сайт и видим что они все равно располагаются 
        как блоки. Это потому что в верстке между тегами эсайд и контентом есть перенос на новую строку и этот отступ некоторые
        браузеры учитывают, поэтому полная ширина будет больше чем 100%. Можно конечно удалить отступ в хтмл файле и разместит
        тег контент сразу за эсайдом без пробелов, но это очень портит читабельность верстки. Вместо этого можно добавить
        обтекание элемену эсайд(флекс еще не рассматривали, поэтому пока так).

            .sidebar {
                display: inline-block;
                width: 25%;
                padding: 32px;
                float: left;
            }

            .content {
                display: inline-block;
                width: 75%;
            }

        Карточки. Так как на странице должно отображаться 2 карточки в ряду, то задаем дисплей инлайн-блок. Ширина 45% что бы когда
        обе займут свое место осталось место для отступа между карточками и контейнером - контент. height: fit-content; - означает
        что высота карточки будет столько сколько занимает контент. Отступы по бокам по 2.5%, что бы в сумме получилось 100%, но
        помним про микро отступы и тоже прописываем флоат лефт. Чтобы ничего из контента не виходило за пределы карточки задаем
        overflow: hidden;.

            .card {
                display: inline-block;
                width: 45%;
                height: fit-content;
                margin-bottom: 32px;
                margin-right: 2.5%;
                margin-left: 2.5%;
                float: left;
                background-color: #222;
                border-radius: 5px;
                overflow: hidden;
            }

        Кард хедер. Делаем позишн релетив чтобы потом задать позшн абсолют вложенным тайтлу и спану и спозиционировать их 
        относительно родителя, высоту, и оверфлоу хиддн. Задаем картинку и стили такие же как к предыдущей
            .card__header {
                position: relative;
                height: 250px;
                overflow: hidden;
                background-image: url("../img/movie.jpg");
                background-position: center center;
                background-size: cover;
            }

        Кард тайтл. Позишн абсолют  -выставляем относительно родителя. Увеличим шрифт. 
            .card__title {
                position: absolute;
                left: 16px;
                bottom: 32px;
                font-weight: 900;
            }

            .card__info {
                position: absolute;
                left: 16px;
                bottom: 16px;
                color: #ff7474;
                font-weight: 900;
            }

        Описание фильма + режисер. Паддинги, немного уменьшим шрифт в относительных единицах, и лайн хай чтобы было большее 
        растояние между строками для лучшей читабельности. А у элемента p (параграф) есть внешний отступ по умолчанию, его 
        нужно убрать.
            .card__content {
                padding: 16px;
                font-weight: 0.9rem;
                line-height: 1.4rem;
            }

            .card__content p {
                margin: 0;
            }

        
        Добавляем вторую карточку в верстку, что бы посмотреть станут ли они в одну линию. Да все хорошо, но заметили эффект
            подпрыгивания когда наводим на сортировку. В стиле этих элементов пропишем туже строку с границей что и для ховера
            но сделаем цвет прозрачный, (border-bottom: solid transparent 5px;) таким образом забронировав место под границу, 
            тогда у ховера можно убрать всё это свойство и оставить только цвет (border-bottom-color: #FF7474;).
            


    Теперь футер.
        
            <footer class="footer">
                <p>Футер</p>
            </footer>
        
        Стили.

            .footer {
                padding: 32px;
                background-color: #221F20;
                text-align: center;
            }



    BEM CSS методологія
    http://getbem.com/introduction/

*/}


{/*    ====    ЭФФЕКТЫ CSS     ====

    +++ TEXT-SHADOW (2.3.1)

        text-shadow может принимать до 4х значений: horizontal shadow, vertival shadow, blur-radius, color.

        Сделаем текст белым, теперь его не видно на белом фоне.
            text-shadow: 2px 2px 6px blue;
            text-shadow: 0 0 3px lime; - эффект светящегося текста.

            Также через точку можно применять несколько наборов теней к элементу.
            text-shadow: 2px 2px 6px blue, 0 0 3px lime;

        Можно использовать для подбора теней ксс генератор, это значительно ускоряет процесс подбора.


        CSS генератор
        http://angrytools.com/css-generator/text-shadow/




    +++ BOX-SHADOW (2.3.2)

        Может принимать до 6ти значений:

            inset   - необязательное, изменяет тень на внутреннюю.
            horizontal shadow
            vertival shadow 
            blur-radius - эффект размытия
            spread      - эффект распространения
            color

            box-shadow: 1px 1px 30px 5px yellow;


        Бывают не типичные случаи. Создадим черный треугольник. В разметке обычный див. К нему применяем стили. Когда прописываем
            ему тень, то тень получается квадратная, так получается потому что ксс использует блочную модель, и даже если на вид
            элемент не прямоугольный для ксс он все равно блок. box-shadow: 0px 0px 30px 5px yellow;

            В таких случаях на помощь приходят фильтры. Теперь тень задается корректно. Фильтры не привязаны к бокс-модели, это
            означает что распознается контур нашей фигура, а прозрачность вокруг нее игнорируется.

            .caret {
                border-left: solid 70px transparent;
                border-right: solid 70px transparent;
                border-bottom: solid 70px black;
                height: 0;
                width: 0;
                filter: drop-shadow(0px 0px 30px yellow)
            }


        *** Фильтры.

            Их можно найти в том-же ксс генераторе и попробовать. Их можно применять несколько на один элемент.
            
            Принимают значения:

            Greyscale   (0-100)     - обесцвечивание
            Blur        (0-30)      - размытие
            Sepia       (0-1)       - эфф. старой фотографии
            Saturate    (0-1)       - обесцвечивание
            Opacity     (0-1)       - прозрачность
            Brightness  (0-200)     - яркость
            Contrast    (0-200)     - контраст
            Hue-rotate  (0-360)     - изменение цветов по цветовой раскладке в градусах
            Invert      (0-100)     - меняет цвета на обратные


        CSS генератор
        https://angrytools.com/css-generator/box-shadow/




    +++ TRANSITION (2.3.3)

        Рассмотрим эффекты ксс transition и transform - при совместном использовании - позволяют делать простые анимации а 
            добавлять взаимодействие и визуальную реакцию для пользователей.

        Добавляя какое-то движение(трансформ) или эффект в свой проект нужно позаботиться чтобы он был простым, тонким и 
            последовательным. Он должен передавать смысл, усиляя взаимодействие с сайтом, а не отвлекать пользователя.

        Transform - изменение(движение) внешнего вида эл.

        Transition - делает изменение плавным. Без него элемент который трансформируется быстро изменяет свое состояние.
                    Принимает значения - property-name - можно указать какое именно свойство будем изменять, duration - как долго
                    будет длится переход, timing-function - ф-я перехода, delay - задержка, через сколько времени начнется процесс
                    перехода(то есть весь процесс будет длиться duration + delay ). Можно задавать в одном свойтве, а можно 
                    каждому свое значение. Обязательным есть только параметр duration.


        ПРИМЕР:
        Рассмотрим сначала простой пример. Создадим круг который будет изменять цвет и превращаться в квадрат при наведении мышки.
            Пустому диву задаем стили. Если не использовать транзишн то будем видеть резкий скачек из одной формы в другую. Добавим
            в circle transition: 1s; и переход сразу стал плавным. 

            .circle {
                width: 300px;
                height: 300px;
                background-color: magenta;
                border-radius: 50%;
                transition: 1s;
            }
            .circle:hover {
                background-color: cyan;
                border-radius: 0;
            }

            Так как мы не указали property-name то transition применился ко всем свойствам. Если укажем 
            transition: background-color 1s; - то плавно измениться только цвет, а форма резко. Если добавим дилей
            transition: background-color 1s 1s; - теперь круг превращается в квадрат, а через секунду плавно изменяется цвет.
            transition: background-color 1s, border-radius: 2s; - через запятую можно указать еще свойства.


        ПРИМЕР 2:
        Теперь пример сложнее, рассмотрим тайминг фанкшн. 4 дива с одинаковыми стилями, общий транзишн 3 секунды, при наведении
            добавляется марджин лефт 300 пкс каждому. Для каждого прописана свой ф-я тайминг: transition-timing-function: чтобы
            мы видели разницу в том как они будут изменяться.
            liner       - движение равномерное
            ease-in     - сначала медленно потом быстро
            ease-out    - сначала быстро потом медленно
            cubic-bezier(0.85, 0, 0.15, 1) - есть и такой вид записи



        Название свойств применяемых по отдельности
            transition-delay (en-US): 0s
            transition-duration: 0s
            transition-property (en-US): всё
            transition-timing-function (en-US): ease   


        Шпаргалка для timing function
        https://easings.net/

        Transition
        https://developer.mozilla.org/ru/docs/Web/CSS/transition





    +++ TRANSFORM (2.3.4)

        Transform - изменение(движение) внешнего вида эл. Можно растягивать(matrix), разворачивать(translate), масштабировать
                    (scale), поворачивать(крутить)(rotate), скручивать(skew), или несколько действий однлвременно.

                
        На примере 4 дива с текстом, завернуты в section им заданы стили для прямоугольника. К дивам обрааемся через псевдокласс
            div:nth-of-type(1){} - обращение к первому. Так как эти дивы без классво и айди то мы обращаемся к ним через этот
            псевдокласс, он используется для добавления стилей элементам определенного типа на основе нумерации в дереве элементов, 
            принимает определенные ключевые слова, цифры(как у нас в примене) или выражения. Через псевдокласс каждому эл. задан
            свой цвет что бы мы их отличали.

            Поставим их по центру с помощью margin: auto; - но так работает только для горизонтального центрирования. Зададим
            марджены вертикальные что бы блоки разъединилсь margin: 70px auto;. Теперь попробуем простое преобразование
            rotate - кручение, может быть задано в градусах (deg), градианах (grad), радианах (rad), оборотах (turn).


            *** ROTATE
            Добавим ховер к каждому диву чтобы трансформ срабатывал при наведении и сделаем поворот на 15 градусов. Так элемент
            поворачивает относительно своего центра, но можно изменить это положения добавив transform-origin. Можно указывать
            ключевыми словами (top left), пикселями (50пкс 50пкс), и даже добавлять смещение в глубину (bottom right 60px).
                
                div:nth-of-type(2):hover{
                    transform: rotate(15deg);
                    transform-origin: top left; - смещение относительно лефого верхнего угла
                }

            
            *** SCALE
            Изменение размера.Принмает одно или два значения.

                transform: scale(0.5);      - уменьшится в половину
                transform: scale(2);        - увеличится в двое
                transform: scale(0.5, 2);   - по оси х уменьшится, по оси у - увеличится.


            *** TRANSLATE
            Перемещает эл. на новое место относительно обычного положения вправо и вниз используя координаты Х и У не задевая
            при этом соседние элементы.

                transform: translate(100px);        - смещение в право 
                transform: translate(100px 50px);   - смещение в право и вниз на 50пкс
                transform: translate(-100px -50px);  - смещение в лево и вверх на 50пкс


            *** SKEW
            Скручивание - используется для деформирования сторон єлемента относительно координатних осей. Значения задаются в
            таких же единицах как и для rotate.

                transform: skew(45deg);         - скручивается по оси Х
                transform: skew(45deg, 35deg);  - скручивается по оси Х и У

            Через пробел можно задавать несколько ф-й
                
                transform: skew(45deg, 35deg) scale(2); - скручивается и увеличивается.



        Название свойств применяемых по отдельности
            Значения ключевым словом
                transform: none;

            Значения функций 
                transform: matrix(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
                transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                transform: perspective(17px);
                transform: rotate(0.5turn);
                transform: rotate3d(1, 2.0, 3.0, 10deg);
                transform: rotateX(10deg);
                transform: rotateY(10deg);
                transform: rotateZ(10deg);
                transform: translate(12px, 50%);
                transform: translate3d(12px, 50%, 3em);
                transform: translateX(2em);
                transform: translateY(3in);
                transform: translateZ(2px);
                transform: scale(2, 0.5);
                transform: scale3d(2.5, 1.2, 0.3);
                transform: scaleX(2);
                transform: scaleY(0.5);
                transform: scaleZ(0.3);
                transform: skew(30deg, 20deg);
                transform: skewX(30deg);
                transform: skewY(1.07rad);

            Мультифункциональные значения 
                transform: translateX(10px) rotate(10deg) translateY(5px);
                transform: perspective(500px) translate(10px, 0, 20px) rotateY(3deg);

            Глобальные значения 
                transform: inherit;
                transform: initial;
                transform: unset;


        Transform
        https://developer.mozilla.org/ru/docs/Web/CSS/transform




    +++ ANIMATION (2.3.6)

        Ітерація - одноразове виконання тіла циклу.

        Благодаря анимации можно выделить основные идеи вашего сайта и добавить интереса к просмотру страницы.

        Пример.
        Есть 2 квадрата. Большой серый родительский и маленький бирюзовый дочерний, находящийся в нем и занимающий в 2 раза меньший
            размер 200пкс. При наведении мышки на большой квадрат сделали перемещение по оси Х на 100%, итого маленький квдрат
            резко прыгает в правый угол. 

            transform: translateX(100%);


        Будем добавлять анимацию чтобы выглядело лучше.  В этом случаем можно использовать 2 решения для плавности движения.
        
        1) использовать transition для небольших анимаций подходит, если нужно просто переместить блок вправо. Правильное 
            расположение transition: 2s ease-in 0.5s; - в селекторе child, потому что если мы расположим его в ховере на этот же
            элемент .parent:hover child{} - тогда плавность будет работать только при наведении мыщки, а при убирании мышки стили
            прописанные в нем перестают работать и квадрат прыгает на старое место.
        
        2) Использовать свойство animation - она немного сложнее в освоении, но позволяет создавать многошаговую анимацию.
            Например с помощью анимации можно сделать что бы квадрат опустился в нижний левый угол потом в нижний правый, а только
            потом в верхний правый и мог повторять это действие. С помощью transition такое сделать не возможно.


        Ксс анимации позволяют анимировать переходы от одной конфигурации ксс стилей к другой. Ксс анимации состоят из 2х
            компонентов: стилевое описание анимации и набор ключевых кадров которые определяют начальное, конечное и возможно 
            промежуточное состояние анимированых стилей.

        У Ксс анимации 3 преимущества перед традиционными способами: 1)простота использования для простых анимаций(можно 
            создавать анимации без JS), 2)анимации будут хорошо работать без сильного нагружания системы, 3)позволяет браузеру 
            контролировать последовательность анимаций, тем самым оптимизируя продуктивность и эффективность браузера.


        Анимировать будем тоже движение что и раньше, закомментируем все лишнее. Можно прописать animation в целом, или
            бращаться к каждому его свойству по отдельности что бы настроить.

            animation-delay
            animation-direction
            animation-duration
            animation-fill-mode
            animation-iteration-count
            animation-name
            animation-play-state
            animation-timing-function


        Чтобы применить анимацию нужно прописать свойство animation в том элементе или его состоянии(как в нашем случае) который
            собираемся анимировать. Первым параметром идет название анимации(там где мы прописываем ключевые кадры). Будем писать
            свойства анимации по отдельности. Имя анимации можно придумать любое, обычно описывают что она делает, в нашем случае
            назовем left-to-right. Дальше зададим ф-ю анимации, она не обязательная, но мы повторим всё то что писали в transition.
            
            .parent:hover child{
                animation-name: left-to-right;
                animation-timing-function: ease-in;
                animation-duration: 2s;
                animation-delay: 0.5s;
                animation-fill-mode: forwards;
            }
        

        Теперь отдельно создаем анимацию и указываем ее назнавние - которое прописано в  animation-name - так мы связываем
            анимацию и ключевые кадры(keyframes). keyframes - не относится ни к одному селектору. В середине keyframes описываем
            как должна себя вести анимация, всё заданное время animation-duration - принимается за 100%, и за это время он должен
            успеть воспроизвести всю зданную анимацию.  0% - описывает с чего начинать анимацию, если этого параметра нету тогда
            начальные данные берутся у селектора для которого прописана анимация( у нас child), при 100% описываем чем должна
            закончится анимация( в нашем случае копируем transform: translateX) - таким способом мы воспроизведем всю анимацию 
            которая была с транзишн, но в конце будет неприятный эффект, потому что кубик после плавной анимации снова прыгает в 
            начальное положение(как только анимация заканчивается keyframes очищается и элементы получают назад свои значения).
            Чтобы исправить такое поведение можно добавить еще свойство animation-fill-mode со знчением forwards - для браузера
            это означает - при окончании анимации оставаться в последнем положении(в нашем случае пока мышка на элементе, пока
            срабатывает ховер, при убирании мышки квадрат все равно прыгает на начальную позицию).

            @keyframes left-to-right {
                100% {transform: translateX(100%);}
            }

        Теперь сделаем перемещение по углам родительского блока.

            @keyframes left-to-right {
                0% {transform: translateX(0);}      - левый верхний
                    33% {transform: translateY(100%);} - в левый нижний
                    66% {transform: translateY(100%) transform: translateX(100%);} - в правый нижний(держа при этом Y(100%))
                100% {transform: translateX(100%);} - правый верхний, убираем трансформ по Y
            }


        Можем не только сделать анимацию но и сказать сколько раз она должна повториться. После каждого раза блок прыгает в 
            начальный угол, чтобы этого не было используем animation-direction - теперь анимация при достижении конца проводится
            в обратном направлении, потом снова анимируется и снова в обратном направлении. animation-play-state - может 
            останавливать или возобновлять анимацию, если пропишем paused- анимация будет на паузен(даже не начинается), если
            running - будет работать(запускается.)

            animation-iteration-count: 3; - повторяется 3 раза
            animation-direction: altrenate;


        Приклади анімації
        https://codepen.io/miocene/pen/mjLPVp
        https://codepen.io/hjdesigner/pen/jvyJdX
        https://codepen.io/kaisle/pen/ZEGwpLb
        https://codepen.io/stivaliserna/pen/jObPyKe 

        Підручник з CSS анімації
        https://cssanimation.rocks/ 

*/}


{/*    ====    ПРАКТИКА (2.3.5)     ====

    Поскольку мы познакомились с некоторыми эффектами - тени, транзишн, трансформ. Финальная версия сайта имеет анимацию карточки
        фильма. При наведении карточка немного поднимается, а снизу остается появляется тень. Название фильма имеет обводку текста,
        а длительность подсветку Займемся этими эффектами. */


{/* Моя реализация

    Подпрыгивание и желтая тень внизу 
        .card {
            transition: translateY .5s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: inset 0px 0px 1px 0px yellow;
        }


    Обводка тайтла
        .card__title {
            text-shadow:  0px 0px 1px black;
        }


    Свечение текста длительности
        .card__info {
            text-shadow:  0px 0px 2px yellow;
        }
    
*/}


/*  Начинаем с анимации - box-shadow сгенерировано с помощью ксс генератора. 0 - гориз тень, 0.5рем - вертикальная + эфф. 
        распространения -0.4rem - размытие, #777 - светленький цвет. В карточке также прописали плавность обоим эффектам.

        .card {
            transition: box-shadow 0.25s, transform 0.25s;
        }

        .card:hover {
            transform: translateY(-0.25rem);
            box-shadow: 0 0.5rem 0.5rem -0.4rem #777;
        }


    Теперь текст. В кард тайтл нужно добавить обводку. Задаем с помощью экспериментального свойства text-stroke, на то время оно
        поддерживалось не всем браузерами на что намекает вендорный префикс  -webkit . И черный цвет обводки с прозрачностью 50%.

        .card__title {
            -webkit-text-stroke: 0.05rem rgba(0, 0, 0, .5);
        }


    Свечение текста длительности
        .card__info {
            text-shadow:  1px 1px 4px rgba(255, 255, 236, 0.7);
        }

    
    В этом проекте используем разные цвета так как мы учимся и сотрим разные способы их задания, но обычно в проекте придерживаются
        одного стиля.

    Много эффектов на странице - плохо, они должны усилять впечатление от страницы, а не отвлекать пользователя.


    Рассмотрим проект и видим что один момент мы могли написать лучше - если в одну карточку добавить больше текста то она станет
        по размеру отличаться от второй и это ломает верстку. Ограничим для карточки показ текста в 3 строчки и появление троеточия
        как знак что там есть еще текст. Для этих параграфов у нас нету классов потому что мы к ним не обращались кроме как убрали
        отступы по умолчанию в .card__content p {. Но так как теперь мы будем добавлять классы которые будут специфическими только
        для параграфов с описанием фильма - присвоим им класс card__description. Некоторые свойства экспериментальные(без вебкит
        не работают - может старый браузер), text-overflow: ellipsis; - вроде как для трех точек после текста, но и без него они
        появляются.

        .card__description {
            display: -webkit-box;           - Делаем коробку из блока???
            -webkit-line-clamp: 3;          - Сколько строк показывать в этой коробке
            -webkit-box-orient: vertical;   - вертикально(может быть и горизонт)
            overflow: hidden;               - скрываем текст который выходит за коробку
            text-overflow: ellipsis;        - вроде как для трех точек после текста
        }

*/}




    //==============================================  ТРЕТЬЯ НЕДЕЛЯ ===============================================================
     

{/*    ====    FLEXBOX та GRID (3.1)    ====

    +++ Що таке Flexbox та Grid? (3.1.1)

        Макет - графічне представлення майбутнього вебсайту, його дизайн. У ньому відображені: колірна гама, шрифти, кнопки, 
            порядок елементів та інше. Від того, наскільки якісно виконано графічне оформлення сторінок, залежить розуміння 
            контенту та загальне сприйняття сайту.

        Контент - інформаційне наповнення сторінок сайту, простими словами, це можуть бути статті блогу, картки товару, тексти 
            сторінок, фотографії, відеоогляди – все, що несе смислове навантаження.


        Когда появился ксс макеты не были такими сложными как сейчас, они были с фиксированной шириной с небольшими вариациями
            размещения блоков. Сегодня наполнение сайтов - большой сложности и потом их еще нужно адаптировать для всех возможных
            разрешений экранов и устройств. Всё это застявляло разработчиков придумывать новые возможности для ксс.


        Рассмотрим 2 самых мощных инструмента ксс flexbox и grid:
            flexbox - с его помощью стало намного легче создавать динамические шаблоны и выравнивать контент в середине контейнеров.
                        Раньше чтобы равномерно расставить блоки в один ряд использовали float и считали отступы при этом помня что
                        отступы для крайних элементов считались по другому чем отступы для тех которые в середине и это не 
                        что страница будемт иметь хороший вид при разных расширениях гарантировало. С появлением flexbox в таких
                        трудностях нету нужды, ксс используя этот инструмент берет на себя всю работу по упорядочиванию блоков.

            grid - появился позже. У него много таких же возможностей что и у flexbox. В одних случаях grid лучше чем flexbox, но
                    в других лучше использовать flexbox.

        Рассмотрим разницу между ними и научимся их использовать.




    +++ Flexbox: вступ (3.1.2)

        flexbox - однонаправленный(для одного измерения) метод разметки для упорядочивания эл. на странице в рядок или колонку, 
                чтобы они вели себя предсказуемо для случаев адаптивности страницы для разных размеров экрана и для разных 
                устройств.

        flex - гибкий. Работа заключается в изменении расстояний между элементами и размера самих элементов в контейнере при 
                уменьшении размера экрана, если дальнейшее изменение не возможно элементы соскакивают в следующий рядок(если они
                находились между другими контейнерами или элементами) или сами элементы в контейнере становятся в колонку и 
                изменяют свой размер, если контейнер был на ширину страницы один(не зажат между другими контейнерами).

        Поддерживается всем современными браузерами и технически с помощью флексбокса можно сверстать полный макет для сайта. Но
            изначально он для этого не предназначался, он больше подходит для стилизации отдельных контейнеров(контейнер главного
            контента, боковая панель, нав панель, хедер, и т.д.), а для построения общего макета больше подходит grid.

        
        Принцып работы flexbox - есть контейнер и его дочерние элементы, задание flexbox разместить элементы так как нужно
            разрабу, тоесть поделить доступное пространство контейнера междй дочерними элементами по конкретным правилам.

        Контейнер становится flex после того как ему прописать свойство display: flex;  или  display: inline-flex; дочерние эл.
            в контейнере при этом автоматически становятся flex items.


        ПРИМЕР:
        Создадим див эл. с классом container и 3 дочерних элемента див с классов container__item и item 1, item 2, item 3.
            Прописали им разную высоту и текст чтобы они отличались. Сейчас они стоят в колонку прижаты к левом краю, так как они
            блочные и не хватает ширины для занятия всего пространства справа. Теперь нам нужно поставить их в строку для этого
            определяем свойство дисплей для контейнера их родительского эл.

            display: flex;

            Теперь все элементы разместились в строку и стали одинаковой высоты(по высоте самого высокого блока, остальные растянуло)
            Когда сужаем окно браузера элементы тоже сужаются игнорируя заданную ширину. При розтягивании элементы прижаты к левой
            стороне браузера и восстанавливают свою ширину(справа остается пустое пространство). Так работает флексбокс - он 
            опирается на наши рекоммендации, но когда их невозможно применить так что б не сломать макет старается выходить из 
            положения. Кроме этого он позволяет стилизовать дочерние эл. контейнера из самого контейнера - размещать доч. эл. в
            рядки и столбцы, выравнивать их в рядках и столбцах, указать как эл. должны увеличиваться или уменьшаться в контейнере.

            Если мы хотим использовать инлайн стили можно применить inline-flex. flex распространяется на контейнер и дочерние эл.
            только первого уровня вложенности, на те которые более вложенные уже не действует.




    +++ Flexbox: container (3.1.3)

        Пропишем стили
            .container {
                position: relative;
                border: 3px solid #333;
                background-color: #09f9dd;
            }

            .container_item {
                width: 150px;
                margin: 10px;
                background-color: #dfdfdf;
                border: 3px solid #333;
                text-align: center;
                color: #333;
            }

            .item-1 {
                min-height: 50px;
            }
            .item-2 {
                min-height: 100px;
            }
            .item-3 {
                min-height: 200px;
            }

            Теперь элементы находятся один над другим и имеют разную высоту. Нам нужно разместить элементы в рядок. Применяем 
                флексбокс
            .container {
                position: relative;
                border: 3px solid #333;
                background-color: #09f9dd;
                display: flex;
            }

        Рассмотрим влекс свойства на уровне флекс контейнера(родительский элемент).

        Главная ось - вдоль которой выравниваются эл. При размещении в рядок она - горизонтальная, при размещ. 
            в колонку - вертикальная.

        Перекрестная ось - перпендикулярна главной оси(поперечная).



        Если хотим стилизовать эл. по *ГЛАВНОЙ оси используем  justify-content: ; свойство, оно определяет как браузер 
            распределяется пространство между и вокруг эл. контента по главной оси флексконтейнера.
        
            По умолчанию  justify-content: flex-start; - можно не прописывать, при этом элементы размещаются один за одним и 
            прижимаются к началу контейнера по главной оси в зависимости от ее направления.

            justify-content: center; - элементы один за одним в центре контейнера по главной оси.
            justify-content: flex-end; - элементы один за одним прижимаясь к концу контейнера по главной оси.
            justify-content: space-between; - первый эл прижат к началу контейнера, последний к концу, а между элементами создается 
                равное расстояние(равномерное распределение)
            justify-content: space-around; - между элементами создается равное расстояние(равномерное распределение) со всех сторон. 
                Например первый эл 35пкс он левого края - 35пкс в право к соседнему элементу, соседний элемент тоже дает по 35пкс в 
                стороны, тогда получается что от краев будет по 35пкс, а между элементами 35+35=70 пкс
            justify-content: space-evenly; При этом способе расстояние между элементами уменьшилось стало 54пкс, а со сторон 
                увеличилось - установилось как 50пкс


                
        Если хотим стилизовать эл. по *ПЕРЕКРЕСТНОЙ оси применяем align-items: ; это свойство выравнивает эл. по перпендикулярной оси.

            align-items: flex-start; - теперь заданная высота блоков вернулась. Эл. липнут к верхнему краю.
            align-items: center;     - теперь заданная высота блоков вернулась. Эл. центрируются.
            align-items: flex-end; - теперь заданная высота блоков вернулась. Эл. липнут к нижнему краю.
            align-items: stretch;   - эл. растягиваются и занимают все доступное пространство контейнера(по умолчанию)- в данном 
                                      случае все элементы стали по высоте равны самому высокому элементу.
    

            Если нужно применить это свойство к конкретному элменту в его селекторе пропишем align-self:
            
            .item-1 {
                align-self: center;
                min-height: 50px;
            }
            Теперь первый элемент уменьшился до своего размера и отцентрировался.


    
        align-content: center; - ничего не изменилось, потому что 1 ряд. Но если бы было больше рядов мы увидели бы. Это свойство 
            похоже на align-items но мужду рядками, задает варавнивание для каждого ряда эл. по перпендикулярной оси.

            Для наглядности работы элайнконтента добавим свойство флекс-врап со значением врап,  Увеличим ширину элементов и 
            высоту контенера до 700пкс.
            flex-wrap: wrap; - определяет должны ли дочерние эл. переносится в мледующий рядок если им мало места или не должны. 
            Тоесть эл. контейнера могут разбится на несколько рядков или размещатся в одном ряду.

            При этом 3й эл. перешел на следующий ряд и стал по центру относительно дополнительной (перпендикулярной оси У), а 
            верхние два элемента растянулись и заняли от этой оси одинаковое расстояние. Но по высоте они заняли место так чтобы 
            от верхнего края эл. первого ряда к верхнему краю окна и от нижнего края эл. второго ряда до нижнего края окна 
            расстояние было одинаковое 50 пкс, тоесть 3й элемент вверх ушел(стал выше центра, потому что он высокий). Но расстояние
            между рядами стало минимальным 6пкс(итого все элементы сгруппировались в центре).

            .container {
                height: 700px;
                position: relative;
                border: 3px solid #333;
                background-color: #09f9dd;
                display: flex;
                flex-wrap: wrap;
                justify-content: space-around;
                align-items: center;
                align-content: center;
            }

            .container_item {
                width: 400px;
                margin: 10px;
                background-color: #dfdfdf;
                border: 3px solid #333;
                text-align: center;
                color: #333;
            }

            align-content: stretch; - при этом расстояние к сторонам верх/низ получилось по 25 пкс. а между рядками 25+25=50пкс
            align-content: flex-start; - все ряды сместились(по дополнительной оси) в верхнюю половину экрана 
            align-content: flex-end;    - все ряды сместились(по дополнительной оси) в нижнюю половину экрана 
            align-content:  space-between; - первый прилип к верхнему краю. второй в нижнему, между ними большое пространство
            align-content:  space-around; - расстояние к сторонам верх/низ получилось по 25 пкс. а между рядками 25+25=50пкс, ведут
                                            себя как при stretch


        flex-direction - свойство указывает как будут располагаться эл. в контейнере по главной оси и направление нормальное или
                    обратное. Выбираем какая ось будет главная.
    
            flex-direction: row; - рядок *(свойство по умолчанию)
            flex-direction: row-reverse; - аналогичный рядок, но элементы идут в другом порядке и липнут теперь к противоположному
                                             краю.
            flex-direction: column; - колонка, при этом высота элементов возвращается и они снова стали разной высоты, контейнер 
                                      по высоте равен сумме всех их высот + отступы, и они все равно липнут к левой части 
                                      контейнера
            flex-direction: column-reverse; - меняется только порядок эл., они все равно липнут к левой части контейнера.




    +++ Flexbox: items (3.1.4)
        
        Свойства контейнера настраивают общее поведение дочерних эл. и общее их размещение. А те свойства которые
            применяем к дочернему элементу отдельно меняют дефолтное поведение одного из элементов, или задаем другой
            размер одному из них. 


        По умолчанию при уменьшении окна браузера элементы равномерно сужаются, но если мы хотим недопустить
            этого для первого элемента пропишем для него flex-shrink: 0;
                
            .item-1 {
                flex-shrink: 0;     - полностью предотвращает сужение элемента.
                min-height: 50px;
            }


        Если нужно что бы один эл занимал всё оставшееся пространство.

            flex-grow: 1;
            
            *Но, так будет работать только если флексгроу указан для одного единственного элемента. Это свойство определяет 
            коэфициент увеличения элемента по отношению к другим элементам в этом контейнере если есть свободное место. В 
            контейнере потомки(дочерние эл) могут располагаться в любом направлении и менять свои размеры - увеличиться чтобы
            заполнить родительский элемент или уменьшится что бы не вылезти за его границы. Коэф. устанавливается цыфрами. 
            
            Если у контейнера три эл. и каждому присвоим флексгроув 1
            то все элменты займут равную площадь, тоесть будут одинаковыми по ширине(может и по всем размерам).
            
            Если для третьего указать флексгроув 2, то он будет расти в ширину в 2 раза больше остальных. Но только прибавляя к
            с своей указанной ширине больше в 2 раза от свободного места в отличие от других эл, так как у нас есть указанная 
            ширина и она одинаковая для всех эл., то на вид этот элемент не будет именно в 2 раза больше двух других.

            .item-3 {
                flex-grow: 1;
                min-height: 200px;
            }


            Для того что бы при таком увеличении элемент игнорировал привязку к ширине можно прописать 

            flex-basis: 0;

            (*нужно добавить для всех элементов). Это свойство определяет начальную ширину эл которая являтся его начальным
            размером, этот размер будет учитываться до того как свободное пространство контейнера начнет распределятся
            между его потомками. Тоесть контейнеры становятся равными 0, и все тело контейнера становится свободным
            местом, после этого происходит распределение.
            Флексбейсис может принимать любые значения как и width и height, а также слова auto и content. Отрицательные
            значения не работают.
            
            .item-3 {
                flex-basis: 0;
                flex-grow: 1;
                min-height: 200px;
            }



        *** ПОРЯДОК(ОЧЕРЕДНОСТЬ) РАЗМЕЩЕЕНИЯ ЭЛЕМЕНТОВ

        Можно изменить порядок отображения элементов на странице не меняя при этом разметку благодаря свойству одер,
        его нужно прописать (каждому?) элементу контейнера и указать какое место в новой очередности он будет занимать
        
            .item-1 {
                order: 2;
                flex-shrink: 0;
                flex-basis: 0;
                flex-grow: 1;
                min-height: 50px;
            }

        *! Это единственное свойство которое *НЕ рекомендуется использовать, потому что оно не влияет на скринридеры,
        которые читают элементы в той последовательности в которой они идут в ХТМЛ а не в заданой через флекс.



        CSS Flexible Box Layout
        https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout 

        Flexbox cheatsheet
        https://yoksel.github.io/flex-cheatsheet/ 




    +++ Grid (3.1.5)

        Лучше рассказать про Grid в сравнении с flexbox. Если флексбокс - это про размещение элементов в одном направлении, то есть
            создание одномерных макетов и динамический расчет их размера отталкиваясь от содержимого блоков(контейнера?).
            То Grid - это тоже самое, только блоки он позволяет размещать не в одном направлении, а в двух(гориз. и вертик.).
            Можно сказать что Grid это флексбокс с расширенными возможностями.

        
        Grid container - такой же как и у флексбокс - это контейнер который содержит в себе все грид эл. В середине размещаются
            грид элем. они могут быть разного размера и занимать разные позиции в середине контейнера. Между элементами есть 
            зазоры на английском - gaps и разделители, так называемая воображаемая сетка которая проходит через все грид эл. и
            создает определенные рамки для их размещения(lines).
        


        ПРИМЕР:
        Создаем див эл. с классом контейнер и в нем 3 дочерних эл. Видим 3 блока размещенных в колонку на всю ширину экрана.

        Для начала работы с гридом по аналогии с флексбоксом пишем для контейнера
            
            .container{
                display: grid;
            }
            
            Обновив страничку ничего не поменялось, потому что сам по себе грид не определяет рядки и колонки как флекс.



        grid-template-colums    
        Чтобы грид начал работать нужно задать специфические колонки и рядки в середине контейнера с помощью grid-template-colums.

            .container{
                display: grid;
                grid-template-colums: 200px 100px:
            }

            Теперь видим что получились 2 колонки, первая шириной 200пкс(1, 3й элементы), а вторая 100пкс(2й элем.).

        Но если мы хотим что бы колонки самостоятельно определяли свой размер базируясь на своем контенте, для этого нужно 
            ввести понятие частицы или fraction unit

            grid-template-colums: 2fr 1fr:

            Теперь ширина контейнера будет поделена на 3 части, две из которых(2/3 экрана) занимает первая колонка, а одну
            занивает вторая колонка. Это работает как уже знакомый flex-grow для первой эквивалентом было бы значение 2, а для
            второй 1. То есть 2фр займет в два раза больше места чем 1 фр, а элементы займут *!всю ширину родительского 
            контейнера.

        
        Добавим еще 2 элемента. Пропишем 4 столбца по 100 пкс, первые 4 элемента в первой строке, а 5й во второй строке в первом
            столбце.

            grid-template-colums: 100px 100px 100px 100px; 

            Такую запись можно заменить, первое число сколько колонок, 2е число - размер колонки(ширина).

            grid-template-colums: repeat(4, 100px);



        grid-template-rows
        Также как столбцы, можно задавать и рядки. 200px - высота для первого,  100px - для второго.
            
            .container{
                display: grid;
                grid-template-colums: repeat(4, 100px);
                grid-template-rows: 200px 150px;
            }

        
        Если не знаем сколько предусмотрено рядков можно указать grid-auto-rows: и одну высоту для всех рядков.

            grid-auto-rows: 150px;


            Можно скомбинировать и задать - так первый ряд будет 200пкс, а все остальные 150.
        
            grid-template-rows: 200px;
            grid-auto-rows: 150px;


        
        Уберем  высоту рядков и добавим много текста в некоторые элементы. В первый наибольшее колличество, во второй меньше. Видим
            что высота колонок выставилась по наиболее заполненому элементу, а во втором элемента есть пустое место после текста.
            Теперь вернем grid-auto-rows: 150px; таким образом текст обрезался, когда высота рядка уменьшилась, а это уже может
            создать проблему, поэтому для таких случаев лучше использовать ф-ю minmax, первый параметр 150 пкс, а второй авто.
            Это значит что если текста мало, то высота рядка будет 150пкс, а если много то высота будет такая чтобы весь текст
            было видно(растянется на столько на сколько ему нужно).

            grid-auto-rows: minmax(150px, auto);

            Теперь видим что первый рядок имеет высоту зависящую от контента, а все остальные стали по 150 пкс. Теперь уберем 
            в эл. много текста и оставим просто их названия.


        Расстояние между столбцами и рядками можно задавать grid-row-gap - между рядкми, grid-column-gap - между колонками.

            grid-row-gap: 20px;
            grid-column-gap: 10px;

            Или задать одинаковое расстояние для всех

            grid-gap: 20px;



        Это были базовые свойства грида. Если их мало посмотрим в сторону grid-template-areas, названия параметров придумываем сами,
            а потом будем использовать:

            .container{
                grid-template-areas:
                "header header"
                "sidebar main"
                "sidebar main";
            }   
            
            Теперь обращаясь к первому грид элементу, задаем ему значение header, которое только что придумали выше. Второму задаем
                sidebar, а третьему main.

            .item-1{
                grid-area: header;
            }
             .item-2{
                grid-area: sidebar;
            }
             .item-3{
                grid-area: main;
            }
            
            Видим что теперь первый эл. растянулся на весь рядок, во втором рядке 2/3х занимает второй элемент и 1/3 третий, в 
                третьем рядке также, это из-за свойства grid-template-colums: 2fr 1fr. А высота первого и третьего рядка = 150пкс,
                а второй очень высокий. Поведение разделения колонок  получилось потому что мы разделили всю площадь на
                2 колонки "header header" и сказали что 2 колонки первого рядка должен занять первый элемент. Второй эл. займет
                2 рядка и 1 колонку, 3й займет тоже 2 рядка и одну колонку "sidebar main" "sidebar main"; - поэтому второй рядок
                занимает двойную высоту, а в 3м рядке разместились 4й и 5й элемент к которым мы не обращались.
            
            То есть  grid-template-areas позволяет по названию эл. обращаться к ним и позиционировать в рядках. Грид учитывает
                ранее заданные размеры для рядков и столбцов и размещает эл. по указанным правилам. Это просто находка если нужно
                перестроить эл. на странице например для разных разрешений экрана. Но чаше чем  grid-template-areas используют
                всетаки обычные колонки и рядки.
                


        Теперь удалим  grid-template-areas и grid-area из элементов и сделаем тоже самое другим подходом. Можно каждому эл. задать
            свойства grid-column-start , так мы указываем с какой колонки эл. должен начинаться. grid-column-end - указывает где
            должна закончится колонка. Лектор говорит что первый эл - 1 колонка, зазор между ними -2 колонка, 2й эл. -3я колонка,
            поэтому нужно указать конец колонки 3. Но я думаю тут все проще, так как разделили мы на 2 колонки из 3х частей
            grid-template-colums: 2fr 1fr.  2 части + 1 часть = 3, то поэтому и нужно ставить 3. Есть еще способ - указать
            grid-column-end: -1; - это будет означать, что колонку нужно растянуть не учитывая количество столбцов которые в нем
            находятся.

            .item-1{
                grid-column-start: 1;   - начало колонки 1
                grid-column-end: 3;     - конец колонки
                grid-column-end: -1;    - альтернативное значение чтобы не заморачиваться с количеством колонок в рядке
            }

            Запись можно укоротить еще больше задав 

                grid-column: 1 / -1;


        Тоже самое можно сделать и для рядков. Для grid-row-start задаем 2 потому что первый рядок уже занят полностью 1м 
            элементом, grid-row-end: 4; - не понят почему 4. При такой записи 2й эл. занял 2 рядка(2й и 3й) и 2 столбца - то есть
            он выше и шире в 2 раза чем эл. 3 и элем. 4 которые находяться справа от него. Эл.5 при этом занимает 2/3х строки 4й 
            получается. Теперь скопируем теже значения для 3го эл. и теперь мы получили такую же разметку как была в предидущем
            примере. 1й эл. растянут на весь первый рядок, во втором рядке 2/3х занимает второй элемент и 1/3 третий с высотой
            в 2 раза большей чем первый и 3й рядки, в 3м рядке также для 4го и 5го элемента, но с обычной высотой.

            .item-2{
                grid-row-start: 2;   - начало эл. в рядке 2
                grid-row-end: 4;     - конец эл. в рядке 4
            }

            .item-3{
                grid-row-start: 2;   - начало эл. в рядке 2
                grid-row-end: 4;     - конец эл. в рядке 4
            }


        Такого же размещения можно добиться и с помощью span.

            .item-1{
                grid-column: span 2;    - занимает все 2 колонки, растягивается на всю страницу
            }

            .item-2{
                rid-column: span 2;     - занимает 2 рядка - из-за этого высота в 2 раза больше чем у 3го рядка
            }

            .item-3{
                rid-column: span 2;     - занимает 2 рядка - из-за этого высота в 2 раза больше чем у 3го рядка
            }



        Теперь удалим стили для элементов а для колонок зададим абсолютные значения и вернемся к свойствам по которым грид похож
            на флексбокс, которые позволяют манипулировать дочерними эл. в середине контейнера. Эти свойства можно поделить на 2
            группы: 1) с помощью которых можно выравнивать эл. в середине грид контейнера, 
                    2) те кторые применяются к каждому грид эл. индивидуально.

            grid-template-colums: 150px 100px:


            1) justify-content - влияет на то где браузер разместит эл. в грид контейнере по горизонтальной оси, растянет или 
                добавит пространство между элементами, а также размещение самого грид контейнера.

                    justify-content: center;    - ставит эл. по центру
                    justify-content: start;     - слева
                    justify-content: end;       - справа
                    justify-content: space-around; - эл. равномерно разместятся в грид контейнере.


                aling-content - выравнивание по вертикальной оси. Для наглядности добавим высоту контейнеру height: 100vh;

                    aling-content: center;     - ставит эл. по центру
                    aling-content: stretch;    - растянет эл. по все высоте контейнера



                Удалим высоту контейнера, установим ширину колонок побольше grid-template-colums: 200px 150px: и теперь будем
                    размещать не контейнер на странице а сами эл. в середине контейнера. 
                    justify-items - это свойство определяет способ выравнивания каждого блока по определенной оси.

                    justify-items: center;      - элементы отцентрированы относительно колонок(первая колонка стала по ширине
                                                    такая же как вторая, тоесть уменьшилась, похоже до размера контента)


                    justify-items - влияет на то как браузер разместит весь грид контейнер и его эл. по вертик. оси.

                    align-items: center;         - элементы отцентрированы относительно центра рядков(все элементы уменьшились по 
                                                    высоте до размера контента в них)

                    align-items: start ;        - элементы отцентрированы относительно верхнего края рядков


                    По умолчанию justify-items и align-items имеют значение stretch. Эти свойства можно переопределить при 
                        обращении к каждому эл. отдельно.

                         .item-1{
                            align-self: start;
                            justify-self: center;    
                        }
                        


        A Complete Guide to Grid
        https://css-tricks.com/snippets/css/complete-guide-grid/

        Grid cheatsheet
        https://yoksel.github.io/grid-cheatsheet/




    +++ Різниця Flexbox та Grid, взаємодія (3.1.6)

        Флексбокс - однонаправленные макеты.

        Грид - двунаправленные макеты(в две стороны).

        Если нужно разместить блоки в одном направлении, например навигацию в хедере, используем флексбокс.

        Если нужно создать макет в двух направлениях - рядки и колонки - используем грид.

        Можно комбинировать например для общего макета грид, а для выравнивания блоков в середине - флекс.

        Грид и флекс дополняют один другого и ни один из них не устареет по этой причине.                        

*/}


{/*    ====    ПРАКТИКА (3.1.7)    ====

    Возвращаемся к нашему проекту кинозала. Проанализируем страницу. Для общей разметки страницы можно приментить грид, условно
        можно разделить страницу на 2 столбца: боковая панель и главный контент, и 4 рядка: хедер, навигация, боковая панель +
        главный контент, футер. Контейнер для всей страницы - body, можно назначать грид ему, но будет лучше завернуть всю 
        разметку в дополнительный контейнер(див эл. с классом container) и не перегружать body.


    Обращаемся к container и прописываем стили, display: grid; - включаем грид, grid-template-columns: 25% auto; - 25% потому что
        ширина боковой панели sidebar = width: 25%; а главный контент занимается все остальное место, эти свойства больше не
        понадобяться поэтому удаляем их + float + display.

        Далее задаем     grid-template-rows, 250пкс - высота хедера, все остальные рядки будут иметь автовысоту которая будет
        отталкиваться от содержимого grid-auto-rows: auto;. Размещаем блоки grid-template-areas и задаем свойства нужным дочерним
        блокам  grid-area: header; и т.д. 


        .container {
            display: grid;
            grid-template-columns: 25% auto;
            grid-template-rows: 250px;
            grid-auto-rows: auto;

            grid-template-areas:
            "header header"
            "nav nav"
            "sidebar main"
            "footer footer";
        }

        Внешний вид сайта остался прежний, но теперь мы используем гриды для разметки и при адаптации страницы под мобильные
            устройства мы увидим все преимущества этого подхода.



    Теперь макет у нас на гридах, а для деталей используем флексбокс, потому что это более легче и удобней, например для 
        выравнивания элементов навигации или блоков основного контента.

        Для навигации будет достаточно в .sort добваить display: flex и настроек по умолчанию будет достаточно чтобы эл. 
            выровнялись в линию по левому краю, теперь можно удалить инлайн-блок из .sort__label, .sort__item {

            .sort {
                grid-area: nav;
                display: flex;   
            }

        Для главного контента нужно больше манипуляций. Добавляем флекс в .контент и убираем из .кард - инлайн-блок, марджин лефт и
            райт, флоат. При этом блоки слиплись и съехали влево, для равномерного распределения пропишем 
            justify-content: space-around; уже хорошо, но что если карточек с фильмами будет больше, скопируем в верстке карточку
            два раза, так чтобы общее количество было 4. Видим что все карточки выстроились в один ряд сузились и слиплись потому
            что им не хватает места, нужно сделать перенос на следующую строку  flex-wrap: wrap, теперь карточки расположились по
            2 в ряд исходя из своих размеров.

            .content {
                grid-area: main;
                display: flex;
                justify-content: space-around;
                flex-wrap: wrap;
            }



    Мы использовали инструменты грид и флекс по своему назнчению. Не нужно выбирать из одной или другой технологии, нужно 
        использовать ту технологию которая более уместна в данной ситуации.

*/}


{/*    ====    ГИБКАЯ ВЕРСТКА (3.2)    ====

    +++ Адаптивна та респонсивна верстка (3.2.1)

        В наше время сайт или моб. приложение должно хорошо выглядеть на любом устройстве. Размеры экрана постоянно изменяются и
            важно чтобы сайт мог самостоятельно под него адаптироваться. Такого можно добиться двумя путями:

            - Responsive - тот который откликается на изменение окна браузера.

            - Adaptive  - тот который адаптируется под разные разрешения устройств.


        Результат одинаковый, но способы достижения разные.

            - Responsive - базируется на одном макете у которого есть гибкая сетка которая перестраивается в зависимости от размера
                            экрана.

            - Adaptive  - базируется на нескольких макетах фиксированной ширины и они заменяют один другого отталкиваясь от размера
                            экрана.


        На практике Responsive встречается чаще потому что он проще в реализации и требует меньше завтрат времени и денег на 
            разработку. Adaptive - делает время загрузки страницы немного меньшим(быстрее загружается) и нацелен на удобство
            пользователя каждого конкретного устройства их успользуют в основном большие компании(фейсбук, почта, амазон).




    +++ Media Queries: вступ (3.2.2)

        Media Queries - правила CSS, які дають змогу керувати стилями елементів залежно від значень технічних параметрів пристроїв.
                        Іншими словами, це конструкції, які дозволяють визначати на підставі деяких умов, які стилі необхідно 
                        використовувати на веб-сторінці, а які ні.

        Брейкпоінт - контрольні точки (тригери) настроюваної ширини, які визначають поведінку адаптивного макета залежно від
                     розмірів пристрою або області перегляду.


        Был период когда для десктопных и моб. устройств использовали разные макеты, Но чем больше ставало моб. устройств тем
            больше нужно было делать таких макетов. И поэтому разрабы искали способ чтобы макеты сами адаптировались уже не под
            конкретное устройство, а под разрешение экрана. В 2012 году с ксс3 были введены Media Queries - ключевая часть
            адаптивного веб дизайна поскольку он позволяю создавать разные макеты в зависимости от размера области просмотра, но
            они также могут использоваться для определения други вещей про окружение в котором работает наш сайт(например
            используется сенсорный экран или мышка, экран находится в портретном(вертикально) или лендскейп(горизонтальном) 
            положении) и базируясь на этой информации тоже изменять разметку.




    +++  Media Queries (3.2.3)

        Рассмотрим пример сайта Standford university(Standford.edu) он хорошо смотрится на широком мониторе, но что бы посмотреть
            как он будет смотреться на мобильном, зайдем в панель разработчика и нажмем toggle device tool (ctrl + shift + M).

            Тут можно выбрать конкретное устройство или разрешение экрана и изменять режим с портретного на лендскейп. Видим что
            все элементы хорошо расположены, то есть сайт хорошо оптимизирован под моб. устройства.


        Схематически Media Queries имеют такой вид. 
           
            @media not | only mediatype and (expressions) {
                CSS code...
            }


            @media - ключевое слово, означает что сейчас будут заданы условия которые обязательно имеют отношение к размеру, типу,
                        положения зоны просмотра веб сайта и стили которые нужно применить при этих условиях.
            
            not | only - не обязательный параметр, должен идти в паре с медиатипом. Например можно указать only print - что означает
                        медиастили нужно использовать только если это версия сайта для распечатки. Можно not | only не использовать
                        вовсе.

            mediatype - медиатип(all, print, screen, speech) - позволяет определить к какому типу носителя нужно использовать 
                        правила all - для всех типов носителей; print - версия сайта для распечатки; screen - все скрины(экраны)
                        компьютеры, смартфоны, планшеты; speech - скринридеры которые озвучивают содерживое веб сайта.

            and (expressions) - тут приводится одно или больше условий (min-width: 480px / max-width: 800px / 
                                orientation: portrait / orientation: landscape). Если условий больше одногоЮ а медиатип это тоже
                                условие то они соединяются оператором and.

            {
                CSS code...     - описывается ксс код который нужно применить если условия исполнены.
            }


        @media (max-width: 760px) {
            .header-title {
                font-size: 38px;
            }
        }


        @media (min-width: 30em) and (max-width: 80em) {    - медиазапрос с двумя условиями
            body {
                background-color: purple;
            }
        }


        Детальнее можно почитать по ссылке, особенно рекомендуют обратить внимание на Media features.

        A Complete Guide to CSS Media Queries
        https://css-tricks.com/a-complete-guide-to-css-media-queries/ 

*/}


{/*    ====    ПРАКТИКА (3.2.4)    ====

            Посмотрим как наша страница выглядит на мобильном устройстве. Выглядит не очень, хоть метатег вьюпорт и разметка + ксс
                стили сделали все что могли. 


            Первый шаг к оптимизации сделан, задан метатег вьюпорт.
            

            Анализируем сайт. Лушче сделать высоту хедера меньше чтобы он не занимал много полезного места, боковое меню можно
                вообще убрать, а каждую карточку фильма разместить в своем отдельном рядке.


            Открываем ксс файл, скролим в самый низ в конец документа, потому что медиа запросы рекомендуется добавлять
                после всех остальных стилей, а если для них отдельный файл то подключать последним. Начинаем с @media, only
                screen - можно пропустить потому что и так понятно что мы делаем верстку для экранов, но мы используем
                как можно больше условий чтобы посмотреть какие они бывают. Потом пишем and потому то будет еще одно условие, а 
                именно при каком размере экрана нужно применять стили которые будут прописаны в середине медиа запроса. 
                
                Имеем первую проблему, как узнать какой размер экрана указать? В основном эти размеры более менее стандартные и 
                разработчики часто пользуются так называемыми брейкпоинтами(но если нужен дизайт под специфический экран, то
                узнаем конкретные размеры и указываем их):

                    320-480 px          -  мобильные устройства
                    481-768 px          - ipad, планшеты
                    769-1024 px         - ноутбуки с небольшим экраном
                    1025-1280 px        - настольные компьютеры, ноутбуки
                    1281 px и больше    - imac, большие настрольные мониторы


                В нашем случае зададим одинаковые стили для мобильных и планшетов при условии макс. ширины 768пкс. Это значит что
                стили которые пропишем дальше будут применены если ширина области просмотра устройства будет от 0 до 768 пкс.

                
                Начнем с элемента контейнер - он отвечает за общую грид сетку, для моб. устройств нам нужно ее перестроить. Все стили
                переписывать не нужно, а только те которые должны измениться. Скопируем стили контейнера которые будут изменяться
                и изменим их вместо двух столбцов будет только один. Высота 250 пкс для телефонов и планшетов большая, достаточно
                будет 100пкс. auto-rows - не будет изменяться, удаляем свойство. В template-areas заменяем сайдбар на мейн.
                
                    @media only screen and (max-width: 768px) {
                        .container {
                            grid-template-columns: auto;
                            grid-template-rows: 100px;
                            grid-template-areas:
                            "header header"
                            "nav nav"
                            "main main"
                            "footer footer";
                        }

                Смотрим - уже лучше но страница съехала влево. Поэтому изменяем дальше. Начнем с хедера - изменим паддинг в 0, а
                фонт сайз уменьшим до 20пкс. Для сайд бар зададим дисплей none чтобы его вообще не было при этом разрешении.
                    .header {
                        padding: 0;
                        font-size: 20px;
                        }

                    .sidebar{
                        display: none;
                    }
                

                Уже лучше - верстка выровнялась, а хедер стал не таким огромным. Теперь нужно сделать чтобы карточка была одна на
                одном рядке. Изменяем ширину с 45% до 100% и задаем отступы 0 сверху и по 16 с других сторон.
                
                    .card {
                        width: 100%;
                        margin: 0 16px 16px 16px;
                    }
                
                Так уже лучше, но еще изменим навигацию, потому что на маленьких экранах принято ее превращать в выпадабщий список 
                (бургер меню). Для этого нужно изменить разметку и добавить JS. В середине тега nav создаем сам бургер - эл. див с
                классом бургер и в нем еще 3 дочерних элемента.

                    <div class="burger">
                        <div class="burger__bar"></div>
                        <div class="burger__bar"></div>
                        <div class="burger__bar"></div>
                    </div>

                Теперь застилизуем эту конструкцию. Стили добавляем в конце стилей для больших экранов, потому что в медиа квери
                принято выносить минимум стилей. Указываем дисплей none потому что при большом экране пользователь его не должен
                видеть. Добавляем стили для burger__bar.
                
                    .burger {
                        display: none;
                    }

                    .burger__bar {
                        width: 25px;
                        height: 3px;
                        margin: 5px auto;
                        background-color: white;
                    }
                
                Чтобы оно появилось на маленьких экранах в медиазапросе назначаем display: inline-block; бургеру. Теперь оно 
                появилось но рядом с элементами старой навигации которые должны быть в середине бургера, а значит не показываться
                тут.

                    .burger {
                        display: inline-block;
                    }

                Чтобы спрятать элементы обращаемся к ним через родителя, можно и напрямую но позже нам расскажут зачем мы сделали
                так. А вокруг бургера зададим паддинги 16 пкс.

                   .sort {
                        padding: 16px;
                    }

                    .sort .sort__label,
                    .sort .sort__item {
                        display: none;
                    }

                Разметка стала приятной. 


                Теперь сделаем так что при нажатии на бургер меню спятанные элементы покажутся.

                9-48
                
                
*/}






















